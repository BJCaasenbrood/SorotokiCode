{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sorotoki - a MATLAB toolkit for soft robotics Sorotoki v3.0.01 stable (Code) Sorobots v1.0 (Soft robot STL) Github page is still under construction. Not all documentation is present at the this stage of development. Sorotoki is an open-source MATLAB toolkit for soft robotics that includes an array of tools for design, modeling, and control. Due to its scientific diversity, it can be challenging for new researchers to quickly familiarize themselves with multiple scientific areas. With the aim to lower this threshold, Sorotoki aims to incorporate multiple layers of soft robotics research into one compact toolkit. Examples include: continuum mechanics, dynamic systems and control theory, topology optimization, computer graphics, and much more to come! The combination provides a highly flexible programming environment and will hopefully aid the development of novel soft robotic research. What can Sorotoki do? Sorotoki started out small, but at its current state, it contains a vast collection of functionalities -- tailored towards many aspects of soft robotics. For example, suppose you are inspired by the multi-gait soft crawler developed by Shepard et al. 1 -- See video . Or you want to simulate the incredibly dexterous soft gripper developed by Suzumori et al. 2 -- See video . Can we model such systems easily? Well.... Short answer: no . As matter of fact, simplifying the (infinite-dimensional) dynamics of soft robots is no easy feat. It has been an active topic of research for the better part of the last two decades. Ironically, studying \"soft\" robotics is incredibly \"hard\" . Sorotoki, however, can simplify the process of design, modeling and control for soft robots. Our aim is to make research into soft robotics more accessable by dividing the problem into smaller, more manageable steps. Multi-physics solvers are included into Sorotoki and can accesses with minimal programming complexity. Simulation of multi-gait crawling soft robot undergoing an undulating motion. The model is inspired by the work of Shepard et al. (2011). Original soft robot can be found here: Youtube video Simulation of multi-finger soft gripper grasping a beaker and manipulating a M10 boltscrew. The model is inspired by the work of Suzumori et al. (1989). Original soft gripper can be found here: Youtube video But, is it easy to code? Well, absolutely! Sorotoki is aimed at removing complexity -- not only for soft robots but also for coding your problems! See the following example codes below: Code for multi-gait soft crawler: Locomotion example Code for multi-finger soft gripper (beaker): Grasping example and Object manipulation example List of functionalities To summarize, some of the functionalities included in the toolkit are listed below: Design: Implicit modeling using signed distance functions (SDFs), 2D-3D mesh generation, computational design using gradient-based optimization Modeling: Finite Element Models (FEM), high-efficiency reduced-order soft beam models (Lagrangian or port-Hamiltonian), easy programmable interconnections of a network of dynamical (soft robot) systems Control: Real-time (pneumatic) control platform using Raspberry Pi, vision-based sensing algorithms using Intel Realsense Depth camera Visualization: Fast and responsive 3D graphics rendering, mesh deformation modifiers (scaling, rotation, bending, twisting, mirroring), Forward Kinematic/Inverse Kinematic-rigging Accessibility: Minimal programming environment (i.e, focused on expressing complex problems with minimal lines of code). Open hardware: Four 3D-printable soft robots (e.g., soft hand, soft manipulator), and control interface). Short examples Example 1: PneuNet deformations A classic example in soft robotics is the PneuNet soft bending actuator. The PneuNet (pneumatic network) belongs to a class of soft actuators that, due to a geometrically induced stiffness differential, undergoes bending when pressurized. The geometry of the PneuNet is developed (and popularized) by Mosadegh et al. 3 , but historically it is much older 4 . To model the PneuNet actuator, consider the following numerical example. Assuming plane strain , we can simulate the nonlinear bending characteristics of the Pneunet actuator using the super-short code below (only 10 lines of code!): Code for simulation % generate mesh from image msh = Mesh ( 'Pneunet.png' , ... 'ElementSize' , 1 , ... 'BdBox' , [ 0 , 120 , 0 , 20 ]); % finite element solver (FEM) fem = Fem ( msh , 'Material' , NeoHookean ( 1.0 , 0.4 ), ... 'TimeStep' , 1e-2 ); % boundary conditions fem = fem . addGravity (); fem = fem . addPressure ( 'All' , 30 * kpa ); fem = fem . addConstraint ( 'Left' , [ 1 , 1 ]); % magic fem = fem . solve (); % take away message: simplicity > complexity Code for plotting Once a simulation is completed, there exist simple command to export the simulation as a .gif file. We can simple use the command below. This sets the frames-per-second (FPS), the axis for the replay video, and gif = true to make a gif file. fem . replay ( 'fps' , 60 , ... 'axis' ,[ - 33 , 120 - 86 21 ], ... 'gif' , true ) Example 2: Fitting hyper-elastic materials Soft robots own their name to soft materials. It is therefore of paramount importance that the constitutive material models reflect the mechanical nature truthfully. However, finding the \" true \" material parameters for these material models can be challenging without the proper tools. Sorotoki is equipped with tools for hyper-elastic material fitting. Consider for instance the cubic Yeoh model: \\[ \\Psi_{\\textrm{YH}}(I_1; \\pi) = \\sum_{i = 1}^3 \\pi_i (I_1 - 3)^{i} \\] where \\(I_1 = {\\lambda_1}^2 + {\\lambda_2}^2 + {\\lambda_3}^2\\) is the first strain invariant, and \\(\\pi\\) a vector of unknown material parameters. For uniaxial tension, we have that \\(\\lambda_1 = \\lambda\\) and \\(\\lambda_2 = \\lambda_3 = 1/{\\lambda^2}\\) . Therefore, the stress along the uniaxial tension test is given by \\( \\sigma_{11} = 2 \\left(\\lambda^2 - \\frac{1}{\\lambda} \\right)\\Psi' \\) with \\(\\Psi'\\) the partial derivative of \\(\\Psi\\) with respect to \\(I_1\\) . Luckily, these uniaxial stress-strain relations are included in every hyperelastic material model of Sorotoki. Simply call S = material.uniaxial(x) . The optimal material parameters \\(\\pi\\) can then be easily found using standard optimization routines such as fmincon . See the example below. Code for simulation % CODE: Example 2 -- Material fitting using fmincon [ lam , str ] = materialDataBase ( 'DragonSkin10' ); % define objective (Yeoh model) obj = @( Pi ) Objective ( Pi , lam , str ); Pi0 = [ 0.0 , 0.0 , 0.0 ]; % initial guess lb = [ 1e-6 , - 2 , - 2 ]; % lower bounds ub = [ Inf , Inf , Inf ]; % upper bounds opt = optimoptions (@ fmincon , 'FiniteDifferenceStepSize' , 1e-12 , 'Algorithm' , 'sqp-legacy' ); fig ( 101 ,[ 9 , 9 ]); Pi = fmincon ( Obj , Pi0 ,[],[],[],[], lb , ub ,[], opt ); function obj = Objective ( Pi,X,Y ) Q = diag ( Y .^- 2 ); % weighting - emphasis low strains E = Y - YeohMaterial ( Pi ). uniaxial ( X ); % stress resid. % quadratic lost function obj = E (:). ' * Q * E (:); cla ; plot ( x , y , 'Color' , color_light_gray ); hold on ; plot ( x , YeohMaterial ( Pi ). uniaxial ( x ), ... 'Color' , color_visited_alt ); ylabel ( 'engineering stress $\\sigma_{11}$' ); xlabel ( 'stretch $\\lambda$' ); end Example 3: Task-space controller for soft manipulator The next example shows the implementation of model-based controllers in Sorotoki. Consider a soft tentacle of length \\(L = 100\\) mm, radius \\(R = 5\\) mm, and a tapering of \\(75\\%\\) . We assume the tentacle is composed of DragonSkin10A silicone. \\[\\tau = J_v^\\top\\left[k_p (X_d - X) - k_d \\dot{X}\\right] + \\nabla_q \\mathcal{V}\\] where \\(J_v(q) := \\lfloor J(q,L) \\rfloor_3\\) is the linear velocity part of the manipulator Jacobian matrix at the tip ( \\(\\sigma = L\\) ), \\(\\nabla_q \\mathcal{V}\\) is simply the gradient of the potential energy w.r.t to its states \\(q\\) , \\(X\\) and \\(X_d\\) the end-effector position and the desired position, respectively. Note that we can compute the end-effector velocity by \\(\\dot{X} = J_v(q) \\dot{q}\\) . Code for simulation % CODE: Example 2 -- Task-space controller % assign desired setpoint Xd = [ 30 ; 10 ; 10 ]; % build continuum shape POD = chebyspace ( 60 , 3 ); % POD basis shp = Shapes ( POD ,[ 0 , 3 , 3 , 0 , 0 , 0 ], ... % pure bending XY 'Length' , 100 , ... 'Material' , Dragonskin10 ); % geometry and boundary conditions shp = shp . setRadius ( 5 ); % R = 5 mm shp = shp . setRamp ( 0.75 ); % R is reduced by 75% at s=L shp = shp . addGravity (); % model composer mdl = Model ( shp , 'TimeStep' , 1 / 60 , ... 'Controller' , @( x ) tau ( x , Xd ) ); % magic ;) mdl = mdl . simulate (); % task-space controller (called by solver) function tau = tau ( mdl,Xd ) log = mdl . Systems { 1 }. Log ; X = log . FK . g ( 1 : 3 , 4 , end ); Jv = log . FK . J ( 4 : 6 ,:, end ); Vq = log . PH . dVdq ; tau = Jv . '* ( 1e-3 * ( Xd - X ) - 1e-4 * Jv * log . dq ) + Vq ; end Code for plotting % Example 2b: plotting Model data % for loop over Model log files for ii = 1 : numel ( mdl . Log . t ) shp = shp . render ( mdl . Log . x ( ii , 1 : 6 )); % render shape if ii == 1 , % render setpoint Xd plotpoint ( Xd ); end axis ([ 0 100 - 5 , 5 , - 10 , 30 ]); view ( 30 , 30 ); drawnow ; end Example 4: Open-loop control of soft hand % CODE: Example 3 -- Open-loop controller % connect to controller board brd = Bdog ( 'pi' , '192.168.0.2' , 'pwd' , ... 'NVeab' , 3 ); % set board update frequency brd = brd . set ( 'Frequency' , 120 ); % phase offset per finger phi = @( k ) ( k - 1 ) * pi / 6 ; %% execute control loop for T=10s while brd . loop ( 10 ) T = ones ( 5 , 1 ) * brd . t ; Pd = zeros ( 1 , 6 ); Pd ( 1 : 5 ) = 80 * sign ( sin ( 4 * T - phi ( 1 : 5 ). ' )) * ... smoothstep ( t - 1 ); brd . setInput ( Pd ); end % disconnect system brd . disconnect (); How to cite? If you are planning on using Sorotoki in your (academic) work, please consider citing the toolkit @misc { Caasenbrood2020 , author = {Caasenbrood, Brandon} , title = {Sorotoki - A Soft Robotics Toolkit for MATLAB} , year = {2020} , publisher = {GitHub} , journal = {GitHub repository} , howpublished = {\\url{https://github.com/BJCaasenbrood/SorotokiCode}} , } Shepherd, R. F., Ilievski, F., Choi, W., Morin, S. A., Stokes, A. A., Mazzeo, A. D., ...Whitesides, G. M. (2011). Multigait soft robot. Proc. Natl. Acad. Sci. U.S.A., 22123978. Retrieved from https://pubmed.ncbi.nlm.nih.gov/22123978 doi: https://doi.org/10.1073/pnas.1116564108 \u21a9 Suzumori, K., Iikura, S., & Tanaka, H. (1991). Development of flexible microactuator and its applications to robotic mechanisms. Proceedings. 1991 IEEE International Conference on Robotics and Automation. IEEE. doi: https://doi.org/10.1109/ROBOT.1991.131850 \u21a9 Mosadegh, B., Polygerinos, P., Keplinger, C., Wennstedt, S., Shepherd, R. F., Gupta, U., ...Whitesides, G. M. (2014). Pneumatic Networks for Soft Robotics that Actuate Rapidly. Adv. Funct. Mater., 24(15), 2163\u20132170. doi: https://doi.org/10.1002/adfm.201303288 \u21a9 1981 - Robot Arm with Pneumatic Gripper - Nikolai Teleshev (Russian) - cyberneticzoo.com. (2012, April 08). Retrieved from http://cyberneticzoo.com/bionics/1981-robot-arm-with-pneumatic-gripper-nikolai-teleshev-russian \u21a9","title":"Sorotoki - a MATLAB toolkit for soft robotics"},{"location":"#sorotoki-a-matlab-toolkit-for-soft-robotics","text":"Sorotoki v3.0.01 stable (Code) Sorobots v1.0 (Soft robot STL) Github page is still under construction. Not all documentation is present at the this stage of development. Sorotoki is an open-source MATLAB toolkit for soft robotics that includes an array of tools for design, modeling, and control. Due to its scientific diversity, it can be challenging for new researchers to quickly familiarize themselves with multiple scientific areas. With the aim to lower this threshold, Sorotoki aims to incorporate multiple layers of soft robotics research into one compact toolkit. Examples include: continuum mechanics, dynamic systems and control theory, topology optimization, computer graphics, and much more to come! The combination provides a highly flexible programming environment and will hopefully aid the development of novel soft robotic research.","title":"Sorotoki - a MATLAB toolkit for soft robotics"},{"location":"#what-can-sorotoki-do","text":"Sorotoki started out small, but at its current state, it contains a vast collection of functionalities -- tailored towards many aspects of soft robotics. For example, suppose you are inspired by the multi-gait soft crawler developed by Shepard et al. 1 -- See video . Or you want to simulate the incredibly dexterous soft gripper developed by Suzumori et al. 2 -- See video . Can we model such systems easily? Well.... Short answer: no . As matter of fact, simplifying the (infinite-dimensional) dynamics of soft robots is no easy feat. It has been an active topic of research for the better part of the last two decades. Ironically, studying \"soft\" robotics is incredibly \"hard\" . Sorotoki, however, can simplify the process of design, modeling and control for soft robots. Our aim is to make research into soft robotics more accessable by dividing the problem into smaller, more manageable steps. Multi-physics solvers are included into Sorotoki and can accesses with minimal programming complexity. Simulation of multi-gait crawling soft robot undergoing an undulating motion. The model is inspired by the work of Shepard et al. (2011). Original soft robot can be found here: Youtube video Simulation of multi-finger soft gripper grasping a beaker and manipulating a M10 boltscrew. The model is inspired by the work of Suzumori et al. (1989). Original soft gripper can be found here: Youtube video But, is it easy to code? Well, absolutely! Sorotoki is aimed at removing complexity -- not only for soft robots but also for coding your problems! See the following example codes below: Code for multi-gait soft crawler: Locomotion example Code for multi-finger soft gripper (beaker): Grasping example and Object manipulation example","title":"What can Sorotoki do?"},{"location":"#list-of-functionalities","text":"To summarize, some of the functionalities included in the toolkit are listed below: Design: Implicit modeling using signed distance functions (SDFs), 2D-3D mesh generation, computational design using gradient-based optimization Modeling: Finite Element Models (FEM), high-efficiency reduced-order soft beam models (Lagrangian or port-Hamiltonian), easy programmable interconnections of a network of dynamical (soft robot) systems Control: Real-time (pneumatic) control platform using Raspberry Pi, vision-based sensing algorithms using Intel Realsense Depth camera Visualization: Fast and responsive 3D graphics rendering, mesh deformation modifiers (scaling, rotation, bending, twisting, mirroring), Forward Kinematic/Inverse Kinematic-rigging Accessibility: Minimal programming environment (i.e, focused on expressing complex problems with minimal lines of code). Open hardware: Four 3D-printable soft robots (e.g., soft hand, soft manipulator), and control interface).","title":"List of functionalities"},{"location":"#short-examples","text":"Example 1: PneuNet deformations A classic example in soft robotics is the PneuNet soft bending actuator. The PneuNet (pneumatic network) belongs to a class of soft actuators that, due to a geometrically induced stiffness differential, undergoes bending when pressurized. The geometry of the PneuNet is developed (and popularized) by Mosadegh et al. 3 , but historically it is much older 4 . To model the PneuNet actuator, consider the following numerical example. Assuming plane strain , we can simulate the nonlinear bending characteristics of the Pneunet actuator using the super-short code below (only 10 lines of code!): Code for simulation % generate mesh from image msh = Mesh ( 'Pneunet.png' , ... 'ElementSize' , 1 , ... 'BdBox' , [ 0 , 120 , 0 , 20 ]); % finite element solver (FEM) fem = Fem ( msh , 'Material' , NeoHookean ( 1.0 , 0.4 ), ... 'TimeStep' , 1e-2 ); % boundary conditions fem = fem . addGravity (); fem = fem . addPressure ( 'All' , 30 * kpa ); fem = fem . addConstraint ( 'Left' , [ 1 , 1 ]); % magic fem = fem . solve (); % take away message: simplicity > complexity Code for plotting Once a simulation is completed, there exist simple command to export the simulation as a .gif file. We can simple use the command below. This sets the frames-per-second (FPS), the axis for the replay video, and gif = true to make a gif file. fem . replay ( 'fps' , 60 , ... 'axis' ,[ - 33 , 120 - 86 21 ], ... 'gif' , true ) Example 2: Fitting hyper-elastic materials Soft robots own their name to soft materials. It is therefore of paramount importance that the constitutive material models reflect the mechanical nature truthfully. However, finding the \" true \" material parameters for these material models can be challenging without the proper tools. Sorotoki is equipped with tools for hyper-elastic material fitting. Consider for instance the cubic Yeoh model: \\[ \\Psi_{\\textrm{YH}}(I_1; \\pi) = \\sum_{i = 1}^3 \\pi_i (I_1 - 3)^{i} \\] where \\(I_1 = {\\lambda_1}^2 + {\\lambda_2}^2 + {\\lambda_3}^2\\) is the first strain invariant, and \\(\\pi\\) a vector of unknown material parameters. For uniaxial tension, we have that \\(\\lambda_1 = \\lambda\\) and \\(\\lambda_2 = \\lambda_3 = 1/{\\lambda^2}\\) . Therefore, the stress along the uniaxial tension test is given by \\( \\sigma_{11} = 2 \\left(\\lambda^2 - \\frac{1}{\\lambda} \\right)\\Psi' \\) with \\(\\Psi'\\) the partial derivative of \\(\\Psi\\) with respect to \\(I_1\\) . Luckily, these uniaxial stress-strain relations are included in every hyperelastic material model of Sorotoki. Simply call S = material.uniaxial(x) . The optimal material parameters \\(\\pi\\) can then be easily found using standard optimization routines such as fmincon . See the example below. Code for simulation % CODE: Example 2 -- Material fitting using fmincon [ lam , str ] = materialDataBase ( 'DragonSkin10' ); % define objective (Yeoh model) obj = @( Pi ) Objective ( Pi , lam , str ); Pi0 = [ 0.0 , 0.0 , 0.0 ]; % initial guess lb = [ 1e-6 , - 2 , - 2 ]; % lower bounds ub = [ Inf , Inf , Inf ]; % upper bounds opt = optimoptions (@ fmincon , 'FiniteDifferenceStepSize' , 1e-12 , 'Algorithm' , 'sqp-legacy' ); fig ( 101 ,[ 9 , 9 ]); Pi = fmincon ( Obj , Pi0 ,[],[],[],[], lb , ub ,[], opt ); function obj = Objective ( Pi,X,Y ) Q = diag ( Y .^- 2 ); % weighting - emphasis low strains E = Y - YeohMaterial ( Pi ). uniaxial ( X ); % stress resid. % quadratic lost function obj = E (:). ' * Q * E (:); cla ; plot ( x , y , 'Color' , color_light_gray ); hold on ; plot ( x , YeohMaterial ( Pi ). uniaxial ( x ), ... 'Color' , color_visited_alt ); ylabel ( 'engineering stress $\\sigma_{11}$' ); xlabel ( 'stretch $\\lambda$' ); end Example 3: Task-space controller for soft manipulator The next example shows the implementation of model-based controllers in Sorotoki. Consider a soft tentacle of length \\(L = 100\\) mm, radius \\(R = 5\\) mm, and a tapering of \\(75\\%\\) . We assume the tentacle is composed of DragonSkin10A silicone. \\[\\tau = J_v^\\top\\left[k_p (X_d - X) - k_d \\dot{X}\\right] + \\nabla_q \\mathcal{V}\\] where \\(J_v(q) := \\lfloor J(q,L) \\rfloor_3\\) is the linear velocity part of the manipulator Jacobian matrix at the tip ( \\(\\sigma = L\\) ), \\(\\nabla_q \\mathcal{V}\\) is simply the gradient of the potential energy w.r.t to its states \\(q\\) , \\(X\\) and \\(X_d\\) the end-effector position and the desired position, respectively. Note that we can compute the end-effector velocity by \\(\\dot{X} = J_v(q) \\dot{q}\\) . Code for simulation % CODE: Example 2 -- Task-space controller % assign desired setpoint Xd = [ 30 ; 10 ; 10 ]; % build continuum shape POD = chebyspace ( 60 , 3 ); % POD basis shp = Shapes ( POD ,[ 0 , 3 , 3 , 0 , 0 , 0 ], ... % pure bending XY 'Length' , 100 , ... 'Material' , Dragonskin10 ); % geometry and boundary conditions shp = shp . setRadius ( 5 ); % R = 5 mm shp = shp . setRamp ( 0.75 ); % R is reduced by 75% at s=L shp = shp . addGravity (); % model composer mdl = Model ( shp , 'TimeStep' , 1 / 60 , ... 'Controller' , @( x ) tau ( x , Xd ) ); % magic ;) mdl = mdl . simulate (); % task-space controller (called by solver) function tau = tau ( mdl,Xd ) log = mdl . Systems { 1 }. Log ; X = log . FK . g ( 1 : 3 , 4 , end ); Jv = log . FK . J ( 4 : 6 ,:, end ); Vq = log . PH . dVdq ; tau = Jv . '* ( 1e-3 * ( Xd - X ) - 1e-4 * Jv * log . dq ) + Vq ; end Code for plotting % Example 2b: plotting Model data % for loop over Model log files for ii = 1 : numel ( mdl . Log . t ) shp = shp . render ( mdl . Log . x ( ii , 1 : 6 )); % render shape if ii == 1 , % render setpoint Xd plotpoint ( Xd ); end axis ([ 0 100 - 5 , 5 , - 10 , 30 ]); view ( 30 , 30 ); drawnow ; end Example 4: Open-loop control of soft hand % CODE: Example 3 -- Open-loop controller % connect to controller board brd = Bdog ( 'pi' , '192.168.0.2' , 'pwd' , ... 'NVeab' , 3 ); % set board update frequency brd = brd . set ( 'Frequency' , 120 ); % phase offset per finger phi = @( k ) ( k - 1 ) * pi / 6 ; %% execute control loop for T=10s while brd . loop ( 10 ) T = ones ( 5 , 1 ) * brd . t ; Pd = zeros ( 1 , 6 ); Pd ( 1 : 5 ) = 80 * sign ( sin ( 4 * T - phi ( 1 : 5 ). ' )) * ... smoothstep ( t - 1 ); brd . setInput ( Pd ); end % disconnect system brd . disconnect ();","title":"Short examples"},{"location":"#how-to-cite","text":"If you are planning on using Sorotoki in your (academic) work, please consider citing the toolkit @misc { Caasenbrood2020 , author = {Caasenbrood, Brandon} , title = {Sorotoki - A Soft Robotics Toolkit for MATLAB} , year = {2020} , publisher = {GitHub} , journal = {GitHub repository} , howpublished = {\\url{https://github.com/BJCaasenbrood/SorotokiCode}} , } Shepherd, R. F., Ilievski, F., Choi, W., Morin, S. A., Stokes, A. A., Mazzeo, A. D., ...Whitesides, G. M. (2011). Multigait soft robot. Proc. Natl. Acad. Sci. U.S.A., 22123978. Retrieved from https://pubmed.ncbi.nlm.nih.gov/22123978 doi: https://doi.org/10.1073/pnas.1116564108 \u21a9 Suzumori, K., Iikura, S., & Tanaka, H. (1991). Development of flexible microactuator and its applications to robotic mechanisms. Proceedings. 1991 IEEE International Conference on Robotics and Automation. IEEE. doi: https://doi.org/10.1109/ROBOT.1991.131850 \u21a9 Mosadegh, B., Polygerinos, P., Keplinger, C., Wennstedt, S., Shepherd, R. F., Gupta, U., ...Whitesides, G. M. (2014). Pneumatic Networks for Soft Robotics that Actuate Rapidly. Adv. Funct. Mater., 24(15), 2163\u20132170. doi: https://doi.org/10.1002/adfm.201303288 \u21a9 1981 - Robot Arm with Pneumatic Gripper - Nikolai Teleshev (Russian) - cyberneticzoo.com. (2012, April 08). Retrieved from http://cyberneticzoo.com/bionics/1981-robot-arm-with-pneumatic-gripper-nikolai-teleshev-russian \u21a9","title":"How to cite?"},{"location":"contact/","text":"Developer(s) Almost 4,5 years ago, Sorotoki began as a minuscule Matlab folder called librarySoftRobotics . As a starting PhD student, the trenches of the field of soft robotics ran deep and far. Very quickly, the folder grew and grew -- and it was slowly becoming an unorganized mess. The main problem stemmed (and still stems) from its multidisciplinary nature -- each Matlab script solved \"one\" and \"non-generalizable\" solution. There was no cross-compatibility between the code... As a solution, I began collecting my code into one compact toolkit called: Sorotoki -- short for So ft Ro botics To ol Ki t. Main developer Email Google Scholar Github Discord Brandon Caasenbrood works as a Ph.D. candidate in the Dynamics and Control group within the Mechanical Engineering department. He is currently involved in the Wearable Robotics perspective program, which explores soft robotics -- a subfield of robotics where rigid materials are substituted for softer alternatives. Naturally, these systems have major human-robot safety benefits relevant to wearable robotics. Besides, their intrinsic softness allows for higher-degree mobility that is difficult to achieve in their rigid counterparts. The main inspiration for soft robots stems from biology, with the aim of achieving similar performance and dexterity as biological creatures. Although the field has made significant steps have been towards bridging biology and robotics, its innate infinite dimensionality poses substantial challenges on design, modeling, and control. The diligence of achieving similar precision and speed to nowadays\u2019 rigid robots, and ultimately nature, stresses the paramount importance of novel engineering strategies tailored for soft robotics. His research tackles the problems within the design and control of these soft robots by exploring first principle methods. His interest lies in the computational design of continuum structure, nonlinear dynamics, and model-based control in the context of bio\u2011inspired soft robots. The emphasis here is on bridging the gaps between nature and robotics on a hardware and software level.","title":"Developer(s)"},{"location":"contact/#developers","text":"Almost 4,5 years ago, Sorotoki began as a minuscule Matlab folder called librarySoftRobotics . As a starting PhD student, the trenches of the field of soft robotics ran deep and far. Very quickly, the folder grew and grew -- and it was slowly becoming an unorganized mess. The main problem stemmed (and still stems) from its multidisciplinary nature -- each Matlab script solved \"one\" and \"non-generalizable\" solution. There was no cross-compatibility between the code... As a solution, I began collecting my code into one compact toolkit called: Sorotoki -- short for So ft Ro botics To ol Ki t. Main developer Email Google Scholar Github Discord Brandon Caasenbrood works as a Ph.D. candidate in the Dynamics and Control group within the Mechanical Engineering department. He is currently involved in the Wearable Robotics perspective program, which explores soft robotics -- a subfield of robotics where rigid materials are substituted for softer alternatives. Naturally, these systems have major human-robot safety benefits relevant to wearable robotics. Besides, their intrinsic softness allows for higher-degree mobility that is difficult to achieve in their rigid counterparts. The main inspiration for soft robots stems from biology, with the aim of achieving similar performance and dexterity as biological creatures. Although the field has made significant steps have been towards bridging biology and robotics, its innate infinite dimensionality poses substantial challenges on design, modeling, and control. The diligence of achieving similar precision and speed to nowadays\u2019 rigid robots, and ultimately nature, stresses the paramount importance of novel engineering strategies tailored for soft robotics. His research tackles the problems within the design and control of these soft robots by exploring first principle methods. His interest lies in the computational design of continuum structure, nonlinear dynamics, and model-based control in the context of bio\u2011inspired soft robots. The emphasis here is on bridging the gaps between nature and robotics on a hardware and software level.","title":"Developer(s)"},{"location":"install/","text":"Installation The toolkit is easy to install. The fastest and easiest way to acquire the toolkit is through git . We highly recommend using Git, since this allows you also to update the toolkit. Prerequisite toolboxes of MATLAB To use Sorotoki, make sure you have the following dependencies installed: Optimization Toolbox Partial Differential Equation Toolbox Image Processing Toolbox Matlab Coder Step-by-step installation Step 1: Downloading the Sorotoki installation folder You can directly clone the repository using the command: git clone --depth 1 https://github.com/BJCaasenbrood/SorotokiCode.git Alternatively, you can download the latest version of the toolkit below, and unpack the compressed folder at any desired working directory. We do recommend that the installation folder of the toolkit named: SorotokiCode is under the folder ...\\Documents\\Matlab\\ (at least for Windows and Linux OS's). Toolkit installation size (only code): ~20 MB Toolkit installation size (with STL data): ~120 MB \ud83d\uddff Direct-download Sorotoki v.2.19.stable (code) Sorotoki v.2.19.stable (code + STLs) Step 3: Run the installation Once all the prerequisites are (properly) installed, you first have to configure the toolkit with MATLAB's search paths. Setting up these paths is relatively straightforward. Simply run: sorotoki (); The file should be located under ...\\Documents\\MATLAB\\SorotokiCode\\. The toolkit will proceed the installation by building search paths in Matlab. The toolkit will request the installation of the prerequisite toolboxes if they are not installed. These include: Optimization Toolbox, Partial Differential Equation Toolbox, Image Processing Toolbox and Matlab Coder. Especially the latter ensures that embedded Sorotoki functions can be converted to c or c++ equivalent code in the form of mex files; that greatly enhances computational performance. Finally, a verification routine is performed that checks if the toolkit is installed correctly. Step 4: That's it folks And that's it, Sorotoki is now ready to use. The sorotoki installation command can also be used to run demo, check updates, see version number, and find the documentation file. You can do these by running the following commands: sorotoki demo % list demos sorotoki d % ... sorotoki version % version (and do i need to update?) sorotoki v % ... sorotoki doc % documentation link sorotoki i % ... Darn', problems during installation? Please let me know by: Post an issue at: https://github.com/BJCaasenbrood/SorotokiCode/issues Get help directly at our Discord server","title":"Installation"},{"location":"install/#installation","text":"The toolkit is easy to install. The fastest and easiest way to acquire the toolkit is through git . We highly recommend using Git, since this allows you also to update the toolkit. Prerequisite toolboxes of MATLAB To use Sorotoki, make sure you have the following dependencies installed: Optimization Toolbox Partial Differential Equation Toolbox Image Processing Toolbox Matlab Coder","title":"Installation"},{"location":"install/#step-by-step-installation","text":"","title":"Step-by-step installation"},{"location":"install/#step-1-downloading-the-sorotoki-installation-folder","text":"You can directly clone the repository using the command: git clone --depth 1 https://github.com/BJCaasenbrood/SorotokiCode.git Alternatively, you can download the latest version of the toolkit below, and unpack the compressed folder at any desired working directory. We do recommend that the installation folder of the toolkit named: SorotokiCode is under the folder ...\\Documents\\Matlab\\ (at least for Windows and Linux OS's). Toolkit installation size (only code): ~20 MB Toolkit installation size (with STL data): ~120 MB \ud83d\uddff Direct-download Sorotoki v.2.19.stable (code) Sorotoki v.2.19.stable (code + STLs)","title":"Step 1: Downloading the Sorotoki installation folder"},{"location":"install/#step-3-run-the-installation","text":"Once all the prerequisites are (properly) installed, you first have to configure the toolkit with MATLAB's search paths. Setting up these paths is relatively straightforward. Simply run: sorotoki (); The file should be located under ...\\Documents\\MATLAB\\SorotokiCode\\. The toolkit will proceed the installation by building search paths in Matlab. The toolkit will request the installation of the prerequisite toolboxes if they are not installed. These include: Optimization Toolbox, Partial Differential Equation Toolbox, Image Processing Toolbox and Matlab Coder. Especially the latter ensures that embedded Sorotoki functions can be converted to c or c++ equivalent code in the form of mex files; that greatly enhances computational performance. Finally, a verification routine is performed that checks if the toolkit is installed correctly.","title":"Step 3: Run the installation"},{"location":"install/#step-4-thats-it-folks","text":"And that's it, Sorotoki is now ready to use. The sorotoki installation command can also be used to run demo, check updates, see version number, and find the documentation file. You can do these by running the following commands: sorotoki demo % list demos sorotoki d % ... sorotoki version % version (and do i need to update?) sorotoki v % ... sorotoki doc % documentation link sorotoki i % ...","title":"Step 4: That's it folks"},{"location":"install/#darn-problems-during-installation","text":"Please let me know by: Post an issue at: https://github.com/BJCaasenbrood/SorotokiCode/issues Get help directly at our Discord server","title":"Darn', problems during installation?"},{"location":"release/","text":"Release Notes 2.07.22 - July 22 - 2022 Documentation update to the examples Modeling. Added minor description in auxilary functions in /src/ Fem.m Generated new mex files for the Local element computation. Now each matrix computation in during the fem simulation calls a .mex64 file. This significantly improves performance ~40% compare to .m files. During install, Sorotoki will ask to install the new mex files. Added (proper) friction effects to the contact simulations. A good example is fem_bouncingball.m which initally started spinning due to improper implementation of the friction forces during contact. The interaction friction can be modified under Material.Cfr (default = 1e-6 for most sample materials). Added example to show the friction effects is: ./scripts/fem/2D/dynamics/fem_crawler.m High interaction friction forces lead to instabilities, implement with caution. A fix will be issued later. Added initial conditions to the dynamic Fem simulations. Now Fem.Utmpcan be overwritten before calling fem.simulate. This can be extremely handy if we like to simulate from a quasi-static equilbrium, e.g., gravity deflection. One can first call fem.solve(), get the displacement through U0 = fem.Log.U(end,:) , then a new simulation: fem . reset (); fem . set ( 'Utmp' , U0 ); fem . simulate (); We can also ensure there is no ramping of the gravity force by setting the following fem.set('GravityRamp',false); Shapes.m Major update to the class. Now, Shapes.reconstruct() will produce better POD bases from the finite element simulations. As example: shp = Shapes ( fem , Modal , 'NNode' , 100 , 'L0' , 120 , 'FilterRadius' ,[ 15 , 15 ]); shp = shp . reference ([ 0 , 0 ],[ 119 , 0 ]); shp = shp . reconstruct (); This code will generate a basis from the data in Fem, and project its dynamics onto a curve spanned by the points: (0,0) -> (119,0). During the reconstruction, all system tensors are build accordingly. Shapes.show() is implemented and will show the strain basis. Model.m Fixed a minus error in the gravitional force compuation that lead to incorrect orientation of the gravity vector. 2.05.19 - May 19 - 2022 Fem.m : Addressed to solve Issue #7 : Fixed issue with Fem.Log. If a nonlinear residual increment takes less than 2 iterations, data was not properly stored. To solve this, any nonlinear time increment must take at least two steps, as to ensure a new displacement field is introduced to the stress-strain calculations. 2.05.17 - May 17 - 2022 Added MEX compiler for Model, Gmodel, and Fem classes. This significantly improves the computation times of the Sorotoki toolkit. When calling sorotoki.m , the installer asks to compile the mex files. Note we do not support the original Matlab functions anymore, simple because of computational speed. Hence, the Matlab Coder Toolkit is a prerequisite for Sorotoki. Updated verifySorotoki.m to include also Model. Shapes Updated the Fem -> Shapes converter that extracts the geometric modes from dynamic or quasi-static FEM data. This can be done using shp.Fem = Fem followed by shp.reconstruct , shp.rebuild . Then a dynamic model can be generated using mdl = Model(shp) . We call this new strain basis the Geometry-Informed Variable Strain basis as the geometry of the soft robot is preserved into the functional basis. Added Shapes.Material. Now hyper-elastic materials can be loaded into the stiffness and inertia tensor construction. The work is experimental since more research is required to properly include hyper-elastic materials into the Cosserat beam models. Model Added an auxiliary flow function to the Model class: dx = f(x,t) . This can be used for integrator actions, like PI controllers. or adaptive controllers where unknown parameters evolutions can be included. 2.01.28 - Jan 28 - 2022 Improved stability of Newmark solver. 2.24.01 - Jan 24 - 2022 Fixed broken installer. vernum.m file was missing on Repo. It has been replaced with soropatch.m which also includes the patch notes. @martijnschouten Missing DOI for citation, and long-term support/access. Signed Distance Functions : Added a new function Sdf.showcontour() . It will show the contour of 2D signed distance functions. Currently not implemented for 3D Sdfs. 2.13.01 - Jan 13 - 2022 Moved SOROTOKI from early alpha to alpha (prepping for official release). Shapes.m : Significant update to the class Shapes. Shapes now requests a Fem class , a Matlab function_handle of functionals, or a evaluated matrix of shape functions (); to construct the class. Then, it serves as an input for the class Model (e.g., dynamic modeling of soft robots), or as an Inverse Kinematic solver for beam models. Added a function Shapes.jointEstimate(Fem) . This will produce an optimal set of modal coefficient to reconstruct the beam model from FEM-driven data (accessed by Fem.Log). Current Shapes.jointEstimate() exploits the fact that the shapes are orthonormal w.r.t. their integral over the spatial domain [0,L]. If shapes do not satisfy this conditions, inaccurate estimates can occur. Added Y = gsog_poly(X) which ensure the columns of Y are mutually orthonormal derived from the matrix X. X must be full-rank. This function is simply the gramm-smith method for the innerproduct space int_C y_i y_j ds on the domain C := [0,L]. 1.12.06 - Dec 6 - 2021 Fem.m : Fixed some numerical issues with Fem.simulate() function. Stability is now further improved for larger timesteps. Fixed some numerical issues with Fem.Contact . A wider range of TimeSteps result now in stable solutions. Still the timestep size should be taken with care. Also fixed the issues of induced (unstable) oscillations due to fast impact. Contact is now based on the initial Modulus of the hyper-elastic material,i.e., Material.Emod() . Added time-base function_handle for the external pressures in dynamic finite-element simulations. They can added using: Fem.AddConstraint('Pressure',id, @(t) sin(t)) ; Dynamic simulations now record the potential and kinetic energies. Future implementation will have Load and Tendon-based dynamic forces The potential energy of the external load is still missing... 1.12.02 - Dec 2 - 2021 Finite Elements : Added Fem.simulate() function to the Nonlinear Finite Element. The function is a standard Newmark-Beta dynamic solver routine for NLFEM. Alternatively, fem.simulate() can be used as an alternative for fem.solve() by setting the Fem.Material.Zeta large (overdamped). Fixed the stability issue of Fem.Contact. Contact can now be added with Fem.AddConstraint('Contact',@(x) sdf(x), [x,y]) (x and y move the SDF). for best stability, use Fem.simulate() with a TimeStep < 1/75 . Open issues : Fem.simulate does not use dynamic external forces, rather the forces are scaled with a sigmoid function f_ext = f*sigmoid(t); This will be removed in the future with fext = @(t) f* .... - an explicit function of time that can be evaluated at time t. Possible implementations: Displace, Load, Pressure, Gravity. 1.10.06 - Oct 6 - 2021 Added patch.md file to keep track of any changes to SOROTOKI. Meshing : Fixed an issue where Mesh.showSDF was not producing plots. 1.10.01 - Oct 1 - 2021 Official beta release of SOROTOKI","title":"Release Notes"},{"location":"release/#release-notes","text":"","title":"Release Notes"},{"location":"release/#20722-july-22-2022","text":"Documentation update to the examples Modeling. Added minor description in auxilary functions in /src/ Fem.m Generated new mex files for the Local element computation. Now each matrix computation in during the fem simulation calls a .mex64 file. This significantly improves performance ~40% compare to .m files. During install, Sorotoki will ask to install the new mex files. Added (proper) friction effects to the contact simulations. A good example is fem_bouncingball.m which initally started spinning due to improper implementation of the friction forces during contact. The interaction friction can be modified under Material.Cfr (default = 1e-6 for most sample materials). Added example to show the friction effects is: ./scripts/fem/2D/dynamics/fem_crawler.m High interaction friction forces lead to instabilities, implement with caution. A fix will be issued later. Added initial conditions to the dynamic Fem simulations. Now Fem.Utmpcan be overwritten before calling fem.simulate. This can be extremely handy if we like to simulate from a quasi-static equilbrium, e.g., gravity deflection. One can first call fem.solve(), get the displacement through U0 = fem.Log.U(end,:) , then a new simulation: fem . reset (); fem . set ( 'Utmp' , U0 ); fem . simulate (); We can also ensure there is no ramping of the gravity force by setting the following fem.set('GravityRamp',false); Shapes.m Major update to the class. Now, Shapes.reconstruct() will produce better POD bases from the finite element simulations. As example: shp = Shapes ( fem , Modal , 'NNode' , 100 , 'L0' , 120 , 'FilterRadius' ,[ 15 , 15 ]); shp = shp . reference ([ 0 , 0 ],[ 119 , 0 ]); shp = shp . reconstruct (); This code will generate a basis from the data in Fem, and project its dynamics onto a curve spanned by the points: (0,0) -> (119,0). During the reconstruction, all system tensors are build accordingly. Shapes.show() is implemented and will show the strain basis. Model.m Fixed a minus error in the gravitional force compuation that lead to incorrect orientation of the gravity vector.","title":"2.07.22 - July 22 - 2022"},{"location":"release/#20519-may-19-2022","text":"Fem.m : Addressed to solve Issue #7 : Fixed issue with Fem.Log. If a nonlinear residual increment takes less than 2 iterations, data was not properly stored. To solve this, any nonlinear time increment must take at least two steps, as to ensure a new displacement field is introduced to the stress-strain calculations.","title":"2.05.19 - May 19 - 2022"},{"location":"release/#20517-may-17-2022","text":"Added MEX compiler for Model, Gmodel, and Fem classes. This significantly improves the computation times of the Sorotoki toolkit. When calling sorotoki.m , the installer asks to compile the mex files. Note we do not support the original Matlab functions anymore, simple because of computational speed. Hence, the Matlab Coder Toolkit is a prerequisite for Sorotoki. Updated verifySorotoki.m to include also Model. Shapes Updated the Fem -> Shapes converter that extracts the geometric modes from dynamic or quasi-static FEM data. This can be done using shp.Fem = Fem followed by shp.reconstruct , shp.rebuild . Then a dynamic model can be generated using mdl = Model(shp) . We call this new strain basis the Geometry-Informed Variable Strain basis as the geometry of the soft robot is preserved into the functional basis. Added Shapes.Material. Now hyper-elastic materials can be loaded into the stiffness and inertia tensor construction. The work is experimental since more research is required to properly include hyper-elastic materials into the Cosserat beam models. Model Added an auxiliary flow function to the Model class: dx = f(x,t) . This can be used for integrator actions, like PI controllers. or adaptive controllers where unknown parameters evolutions can be included.","title":"2.05.17 - May 17 - 2022"},{"location":"release/#20128-jan-28-2022","text":"Improved stability of Newmark solver.","title":"2.01.28 - Jan 28 - 2022"},{"location":"release/#22401-jan-24-2022","text":"Fixed broken installer. vernum.m file was missing on Repo. It has been replaced with soropatch.m which also includes the patch notes. @martijnschouten Missing DOI for citation, and long-term support/access. Signed Distance Functions : Added a new function Sdf.showcontour() . It will show the contour of 2D signed distance functions. Currently not implemented for 3D Sdfs.","title":"2.24.01 - Jan 24 - 2022"},{"location":"release/#21301-jan-13-2022","text":"Moved SOROTOKI from early alpha to alpha (prepping for official release). Shapes.m : Significant update to the class Shapes. Shapes now requests a Fem class , a Matlab function_handle of functionals, or a evaluated matrix of shape functions (); to construct the class. Then, it serves as an input for the class Model (e.g., dynamic modeling of soft robots), or as an Inverse Kinematic solver for beam models. Added a function Shapes.jointEstimate(Fem) . This will produce an optimal set of modal coefficient to reconstruct the beam model from FEM-driven data (accessed by Fem.Log). Current Shapes.jointEstimate() exploits the fact that the shapes are orthonormal w.r.t. their integral over the spatial domain [0,L]. If shapes do not satisfy this conditions, inaccurate estimates can occur. Added Y = gsog_poly(X) which ensure the columns of Y are mutually orthonormal derived from the matrix X. X must be full-rank. This function is simply the gramm-smith method for the innerproduct space int_C y_i y_j ds on the domain C := [0,L].","title":"2.13.01 - Jan 13 - 2022"},{"location":"release/#11206-dec-6-2021","text":"Fem.m : Fixed some numerical issues with Fem.simulate() function. Stability is now further improved for larger timesteps. Fixed some numerical issues with Fem.Contact . A wider range of TimeSteps result now in stable solutions. Still the timestep size should be taken with care. Also fixed the issues of induced (unstable) oscillations due to fast impact. Contact is now based on the initial Modulus of the hyper-elastic material,i.e., Material.Emod() . Added time-base function_handle for the external pressures in dynamic finite-element simulations. They can added using: Fem.AddConstraint('Pressure',id, @(t) sin(t)) ; Dynamic simulations now record the potential and kinetic energies. Future implementation will have Load and Tendon-based dynamic forces The potential energy of the external load is still missing...","title":"1.12.06 - Dec 6 - 2021"},{"location":"release/#11202-dec-2-2021","text":"Finite Elements : Added Fem.simulate() function to the Nonlinear Finite Element. The function is a standard Newmark-Beta dynamic solver routine for NLFEM. Alternatively, fem.simulate() can be used as an alternative for fem.solve() by setting the Fem.Material.Zeta large (overdamped). Fixed the stability issue of Fem.Contact. Contact can now be added with Fem.AddConstraint('Contact',@(x) sdf(x), [x,y]) (x and y move the SDF). for best stability, use Fem.simulate() with a TimeStep < 1/75 . Open issues : Fem.simulate does not use dynamic external forces, rather the forces are scaled with a sigmoid function f_ext = f*sigmoid(t); This will be removed in the future with fext = @(t) f* .... - an explicit function of time that can be evaluated at time t. Possible implementations: Displace, Load, Pressure, Gravity.","title":"1.12.02 - Dec 2 - 2021"},{"location":"release/#11006-oct-6-2021","text":"Added patch.md file to keep track of any changes to SOROTOKI. Meshing : Fixed an issue where Mesh.showSDF was not producing plots.","title":"1.10.06 - Oct 6 - 2021"},{"location":"release/#11001-oct-1-2021","text":"Official beta release of SOROTOKI","title":"1.10.01 - Oct 1 - 2021"},{"location":"beam/model/","text":"Model Composer","title":"Model Composer"},{"location":"beam/model/#model-composer","text":"","title":"Model Composer"},{"location":"beam/shapes/","text":"Beam Shapes and Geometry","title":"Beam Shapes and Geometry"},{"location":"beam/shapes/#beam-shapes-and-geometry","text":"","title":"Beam Shapes and Geometry"},{"location":"control/controlboard/","text":"VEAB HAT (RPi) Image caption Schematics of the VEAB Raspberry Pi controller hat Printer-Circuit Board (PCB) Schematics (v2.11) Schematics of the VEAB Raspberry Pi controller hat Bill of material (BOM)","title":"VEAB HAT (RPi)"},{"location":"control/controlboard/#veab-hat-rpi","text":"Image caption Schematics of the VEAB Raspberry Pi controller hat","title":"VEAB HAT (RPi)"},{"location":"control/controlboard/#printer-circuit-board-pcb-schematics-v211","text":"Schematics of the VEAB Raspberry Pi controller hat","title":"Printer-Circuit Board (PCB) Schematics (v2.11)"},{"location":"control/controlboard/#bill-of-material-bom","text":"","title":"Bill of material (BOM)"},{"location":"control/i2chat/","text":"I2C Expander HAT (RPi) Schematics of the VEAB Raspberry Pi controller hat Printer-Circuit Board (PCB) Schematics (v2.11) Schematics of the VEAB Raspberry Pi controller hat Bill of material (BOM)","title":"I2C Expander HAT (RPi)"},{"location":"control/i2chat/#i2c-expander-hat-rpi","text":"Schematics of the VEAB Raspberry Pi controller hat","title":"I2C Expander HAT (RPi)"},{"location":"control/i2chat/#printer-circuit-board-pcb-schematics-v211","text":"Schematics of the VEAB Raspberry Pi controller hat","title":"Printer-Circuit Board (PCB) Schematics (v2.11)"},{"location":"control/i2chat/#bill-of-material-bom","text":"","title":"Bill of material (BOM)"},{"location":"control/orderveab/","text":"Place-and-order (JLCPCB) In the following documentation, we will show how to reproduce the VEAB controller hat (see below) step-by-step. This board can be produced by hand, but a better and easier alternative is to order it from a PCB manufacturer. Step 1: Choosing a PCB manufacturer There exist a couple of options for suitable PCB manufacturers. One we can recommend is JLCPCB located in Shenzhen, China. There website can be found at https://jlcpcb.com . The manufacturing files of the PCB board comply with this manufacturer. For the following steps, its easier to make an account with the PCB manufacturer. Step 2: Download and place gerber files Click on Order now (on the top right). Then add the gerber.zip (this contains all the macturing files for the VEAB control board) which can be downloaded from below: Download PCB gerber files (.zip) Step 3: Setting the PCB options Once the upload is complete, make sure you have \"similar\" options. * A minimum of ten boards must be selected to comply for SMT manufacturing. Alternatively, if you wish to solder the boards by hand, the order number does not matter. Also make sure you select Specify a location under Remove order number Step 4: Selecting SMT manufacturing Once you've selected the PCB setting, we can continue with SMT manufacturing. JLCPCB will not only produce the PCBs but also solder the components for us with this option enabled. Make sure you have the Top selected for the component placement, and also have Added by customers under Tooling holes . These tooling holes might depend on the PCB manufacturer (1.152mm for JLCPCB), and they assist with the component placement. The gerber files already have these holes on the board, thus no extra manufacturing steps are needed to be taken by JLCPCB. Press Confirm , and you'll be taken to a new page. Step 5: Adding the bill-of-materials (BOM) and footprint placement files In order for JLCPCB to assemble the board,they need to know which component are required and where they need to be placed. To do so, they require a bill-of-materials (BOM) and footprint placement file. These files can be found below: Download BOM file (.csv) Download Footprint position file (.csv) Step 6: Checking the JLCPCB's parts (in stock) You'll be greeted with an overview of all the components JLCPCB has in stock. Sometimes, it can happen that these components are not in stock. In most cases, the passive parts like resistors, capacitors, and inductors are in stock; but specialized components like the DACs, ADCs are not. If so, there are two options: Option 1: Find a replacement part that has an identical footprint, value, and property; and replace them in the BOM.csv. Option 2: Continue with the order, and JLCPCB will omit these parts from the assembly. This means you have to order the part elsewhere (i.e., Mouser/Farnell/Digikey) and hand-solder them. (only recommended for those with experience in SMD soldering). Options for the Digital-Analog converter (MCP4725 -- U3, U4): MCP4725A0T-E/CH -- C144198 (recommended) MCP4725A1T-E/CH -- C61423 MCP4726A0T-E/CH -- C191581 Options for the Analog-Digital converter (ADS1013 -- U5, U8): ADS1013IDGSR -- C524815 (recommended) ADS1014IDGST -- C132086 ADS1114IDGST -- C206016 ADS1015IDGSR -- C193969 Options for the buck-boost converter (SB6286 -- U2): SB6286 -- C157668 (recommended) SX1308 -- C78162 SY7208ABC -- C80514 AP2008TCER-ADJ -- C130341 Options for the OP-amp (LM358 -- U1, U6, U7, U9): - LM358DR2G -- C7950 (recommended) - LM358ADR -- C404320 If you wish to choose a different component, make the nessecary changes to BOM.csv under the column LCSC and add the corresponding Cxxxxxx number. In the next step, we will check the placement of these components is correct. Step 7: Checking component placement The next step is crucial -- the component placement. Although JLCPCB will (sometimes) double check any misplacements, it is better to check the placement yourself to be sure. JLCPCB will render the gerber files and the component placement files. Visualizations of bad placements (red boxes) and correct placements (green boxes) are show below. The red dots should match the white dots on the silkscreen. Here, we can see that the orientation of U2,U3, and U4 are off by 180 degrees. To fix the issue (if they may occur), we can modify the orientation in the Footprint_position.csv which can be done using a simple text editor, or using Excel. Possible orientations are: 0,90,180, and 270 ; which can be modified under Rotation in the .csv file. Step 8: Placing your order Once all the orientations are correct, press Save to Cart to finalize the order! Its that easy ;) PCB production is 2-3 days, SMT assembly is 3 days Hence, production time is roughly one week!","title":"Place-and-order (JLCPCB)"},{"location":"control/orderveab/#place-and-order-jlcpcb","text":"In the following documentation, we will show how to reproduce the VEAB controller hat (see below) step-by-step. This board can be produced by hand, but a better and easier alternative is to order it from a PCB manufacturer.","title":"Place-and-order (JLCPCB)"},{"location":"control/orderveab/#step-1-choosing-a-pcb-manufacturer","text":"There exist a couple of options for suitable PCB manufacturers. One we can recommend is JLCPCB located in Shenzhen, China. There website can be found at https://jlcpcb.com . The manufacturing files of the PCB board comply with this manufacturer. For the following steps, its easier to make an account with the PCB manufacturer.","title":"Step 1: Choosing a PCB manufacturer"},{"location":"control/orderveab/#step-2-download-and-place-gerber-files","text":"Click on Order now (on the top right). Then add the gerber.zip (this contains all the macturing files for the VEAB control board) which can be downloaded from below: Download PCB gerber files (.zip)","title":"Step 2: Download and place gerber files"},{"location":"control/orderveab/#step-3-setting-the-pcb-options","text":"Once the upload is complete, make sure you have \"similar\" options. * A minimum of ten boards must be selected to comply for SMT manufacturing. Alternatively, if you wish to solder the boards by hand, the order number does not matter. Also make sure you select Specify a location under Remove order number","title":"Step 3: Setting the PCB options"},{"location":"control/orderveab/#step-4-selecting-smt-manufacturing","text":"Once you've selected the PCB setting, we can continue with SMT manufacturing. JLCPCB will not only produce the PCBs but also solder the components for us with this option enabled. Make sure you have the Top selected for the component placement, and also have Added by customers under Tooling holes . These tooling holes might depend on the PCB manufacturer (1.152mm for JLCPCB), and they assist with the component placement. The gerber files already have these holes on the board, thus no extra manufacturing steps are needed to be taken by JLCPCB. Press Confirm , and you'll be taken to a new page.","title":"Step 4: Selecting SMT manufacturing"},{"location":"control/orderveab/#step-5-adding-the-bill-of-materials-bom-and-footprint-placement-files","text":"In order for JLCPCB to assemble the board,they need to know which component are required and where they need to be placed. To do so, they require a bill-of-materials (BOM) and footprint placement file. These files can be found below: Download BOM file (.csv) Download Footprint position file (.csv)","title":"Step 5: Adding the bill-of-materials (BOM) and footprint placement files"},{"location":"control/orderveab/#step-6-checking-the-jlcpcbs-parts-in-stock","text":"You'll be greeted with an overview of all the components JLCPCB has in stock. Sometimes, it can happen that these components are not in stock. In most cases, the passive parts like resistors, capacitors, and inductors are in stock; but specialized components like the DACs, ADCs are not. If so, there are two options: Option 1: Find a replacement part that has an identical footprint, value, and property; and replace them in the BOM.csv. Option 2: Continue with the order, and JLCPCB will omit these parts from the assembly. This means you have to order the part elsewhere (i.e., Mouser/Farnell/Digikey) and hand-solder them. (only recommended for those with experience in SMD soldering). Options for the Digital-Analog converter (MCP4725 -- U3, U4): MCP4725A0T-E/CH -- C144198 (recommended) MCP4725A1T-E/CH -- C61423 MCP4726A0T-E/CH -- C191581 Options for the Analog-Digital converter (ADS1013 -- U5, U8): ADS1013IDGSR -- C524815 (recommended) ADS1014IDGST -- C132086 ADS1114IDGST -- C206016 ADS1015IDGSR -- C193969 Options for the buck-boost converter (SB6286 -- U2): SB6286 -- C157668 (recommended) SX1308 -- C78162 SY7208ABC -- C80514 AP2008TCER-ADJ -- C130341 Options for the OP-amp (LM358 -- U1, U6, U7, U9): - LM358DR2G -- C7950 (recommended) - LM358ADR -- C404320 If you wish to choose a different component, make the nessecary changes to BOM.csv under the column LCSC and add the corresponding Cxxxxxx number. In the next step, we will check the placement of these components is correct.","title":"Step 6: Checking the JLCPCB's parts (in stock)"},{"location":"control/orderveab/#step-7-checking-component-placement","text":"The next step is crucial -- the component placement. Although JLCPCB will (sometimes) double check any misplacements, it is better to check the placement yourself to be sure. JLCPCB will render the gerber files and the component placement files. Visualizations of bad placements (red boxes) and correct placements (green boxes) are show below. The red dots should match the white dots on the silkscreen. Here, we can see that the orientation of U2,U3, and U4 are off by 180 degrees. To fix the issue (if they may occur), we can modify the orientation in the Footprint_position.csv which can be done using a simple text editor, or using Excel. Possible orientations are: 0,90,180, and 270 ; which can be modified under Rotation in the .csv file.","title":"Step 7: Checking component placement"},{"location":"control/orderveab/#step-8-placing-your-order","text":"Once all the orientations are correct, press Save to Cart to finalize the order! Its that easy ;) PCB production is 2-3 days, SMT assembly is 3 days Hence, production time is roughly one week!","title":"Step 8: Placing your order"},{"location":"fem/fem/","text":"Finite Elements","title":"Finite Elements"},{"location":"fem/fem/#finite-elements","text":"","title":"Finite Elements"},{"location":"fem/mesh/","text":"Mesh generation","title":"Mesh generation"},{"location":"fem/mesh/#mesh-generation","text":"","title":"Mesh generation"},{"location":"fem/sdf/","text":"Implicit CAD List of 3D primitives sSphere.m sSphere ( R ); % sphere with radius R at (0,0,0) sSphere ([ x , y , z ], R ); % sphere with radius R at (x,y,z) sSphere ([ x , y , z ], R , T ); % shell sphere with radius R at (x,y,z) with thickness T sCube.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]); sCylinder.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]); sTorus.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]);","title":"Implicit CAD"},{"location":"fem/sdf/#implicit-cad","text":"","title":"Implicit CAD"},{"location":"fem/sdf/#list-of-3d-primitives","text":"sSphere.m sSphere ( R ); % sphere with radius R at (0,0,0) sSphere ([ x , y , z ], R ); % sphere with radius R at (x,y,z) sSphere ([ x , y , z ], R , T ); % shell sphere with radius R at (x,y,z) with thickness T sCube.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]); sCylinder.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]); sTorus.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]);","title":"List of 3D primitives"},{"location":"plotting/colormaps/","text":"Colormaps Overview fig ( 102 ,[ 10.75 , 10.75 ]); colormaplist = { 'blackwhite' , 'bluesea' , 'heatmap' , 'inferno' , 'metro' , ... 'noir' , 'turbo' , 'viridis' , 'bounce' , 'barney' , 'evolution' , ... 'rainbow' , 'polarmap' , 'redgreen' , 'soapbubble' }; N = numel ( colormaplist ); Nx = ceil ( sqrt ( N )); Ny = ceil ( sqrt ( N )); for ii = 1 : N ax = subplot ( Nx , Ny , ii ) ; colorwheel (); map = str2func ([ '@(x) ' , colormaplist { ii }]); colormap ( ax , map ([])); axis off tight ; end List of colormaps Improved colormaps of Sorotoki Colormap manipulation","title":"Colormaps"},{"location":"plotting/colormaps/#colormaps","text":"","title":"Colormaps"},{"location":"plotting/colormaps/#overview","text":"fig ( 102 ,[ 10.75 , 10.75 ]); colormaplist = { 'blackwhite' , 'bluesea' , 'heatmap' , 'inferno' , 'metro' , ... 'noir' , 'turbo' , 'viridis' , 'bounce' , 'barney' , 'evolution' , ... 'rainbow' , 'polarmap' , 'redgreen' , 'soapbubble' }; N = numel ( colormaplist ); Nx = ceil ( sqrt ( N )); Ny = ceil ( sqrt ( N )); for ii = 1 : N ax = subplot ( Nx , Ny , ii ) ; colorwheel (); map = str2func ([ '@(x) ' , colormaplist { ii }]); colormap ( ax , map ([])); axis off tight ; end List of colormaps Improved colormaps of Sorotoki","title":"Overview"},{"location":"plotting/colormaps/#colormap-manipulation","text":"","title":"Colormap manipulation"},{"location":"plotting/colors/","text":"Colors The standard color schemes are not optimized well (in my opinon). Especially when compared to the MatplotLib in Python. Therefore, Sorotoki comes equipped with a new color scheme. Improved color scheme Using Sorotoki color scheme(s) fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y ); end % magick color change sorocolor ; Improved color scheme for plotting using Sorotoki Alternative option An alternative option is to call the colors directly. We can use this using col(i) where i is the color index. The indexation is identical to the legend above. fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y , 'Color' , col ( ii )); end","title":"Colors"},{"location":"plotting/colors/#colors","text":"The standard color schemes are not optimized well (in my opinon). Especially when compared to the MatplotLib in Python. Therefore, Sorotoki comes equipped with a new color scheme.","title":"Colors"},{"location":"plotting/colors/#improved-color-scheme","text":"Using Sorotoki color scheme(s) fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y ); end % magick color change sorocolor ; Improved color scheme for plotting using Sorotoki Alternative option An alternative option is to call the colors directly. We can use this using col(i) where i is the color index. The indexation is identical to the legend above. fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y , 'Color' , col ( ii )); end","title":"Improved color scheme"},{"location":"plotting/figure/","text":"Figures Making figures in Matlab is hassle some. By default, the background is gray instead of white. The line thickness is 0.5pt instead of a prettier 1.5pt . Also the bounding box of the graphs are not 1.0pt but instead 0.5pt . And the labels are by default not using the .latex interpreter. To make matters worse, we cannot scale figure size by default -- rather a set of commands are required to adjust figure size. To solve this, we introduce the fig() command. Making a fig figure % make figure of size (2^9) x (2^9) = 512 x 512 px fig ( 101 ,[ 9 , 9 ]); ezplot (@( x ) sin ( x ^ 2 )); xlabel ( '$x$' ); ylabel ( '$\\sin(x^2)$' ); Sorotoki figure Figure of size 512x512 pixels produced using fig() How about standard Matlab? Standard matlab figure result","title":"Figures"},{"location":"plotting/figure/#figures","text":"Making figures in Matlab is hassle some. By default, the background is gray instead of white. The line thickness is 0.5pt instead of a prettier 1.5pt . Also the bounding box of the graphs are not 1.0pt but instead 0.5pt . And the labels are by default not using the .latex interpreter. To make matters worse, we cannot scale figure size by default -- rather a set of commands are required to adjust figure size. To solve this, we introduce the fig() command. Making a fig figure % make figure of size (2^9) x (2^9) = 512 x 512 px fig ( 101 ,[ 9 , 9 ]); ezplot (@( x ) sin ( x ^ 2 )); xlabel ( '$x$' ); ylabel ( '$\\sin(x^2)$' ); Sorotoki figure Figure of size 512x512 pixels produced using fig() How about standard Matlab? Standard matlab figure result","title":"Figures"},{"location":"plotting/rendering/","text":"Rendering","title":"Rendering"},{"location":"plotting/rendering/#rendering","text":"","title":"Rendering"},{"location":"sorobots/softhand/","text":"Soft Robotic Hand About Fabrication details The soft hand is fully printable. Below, we provided a list of the printer materials. 4 \\(\\times\\) : Soft Finger - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Soft Thumb - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Finger Connector - Rigid 10k - Formlabs (recommended) 1 \\(\\times\\) : Rigid Palm - Prusament PLA White - Prusa (optional) 1 \\(\\times\\) : Rigid Base - Prusament PLA White - Prusa (optional) Printing of Elastic 80A When printing Elastic 80A, the recommended supports for the material are very thick -- thus difficult to remove. We recommend generating the supports using Rigid 10K , then change the material to Elastic 80A . Support can then be easily removed manually (no pliers required). Cleaning and closing of Soft Actuators A crucial step is cleaning of the elastic resin parts. If residual resin is not properly removed/cleaned, it will greatly affect the quality and performance of the soft actuator. We recommend following the cleaning procedures proposed in Proper et al. [^1], see Git documentation . The paper draft can be found here: Paper.pdf . In their approach, a perastaltic pump is used to pump cleaning fluid through the soft actuator prior to curing. To allow fluid to flow, both sides of the soft actuator are open! They must be closed using 3 mm plug printed from the same material! The plug can be glued in place using uncured resin, and then placed in an UV chamber for a short duration. Connecting Soft Actuator to Rigid Connector Similar to closing of the soft actuators, uncured resin can be used to make a robust connection to the rigid pressure connector. This greatly improves air-tightness of the complete system. Downloadable content Complete Soft Robot Hand - uncompressed 14.3 MB (zip) Rigid Palm (STL) Rigid Base (STL) Finger Connector (STL) Soft Finger(s) (STL) Soft Thumb (STL) 3D Visualization var iframe = document.getElementById( 'api-frame' ); var uid = 'f8ffac8550114147bf9483dd2c8edb72'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } );","title":"Soft Robotic Hand"},{"location":"sorobots/softhand/#soft-robotic-hand","text":"","title":"Soft Robotic Hand"},{"location":"sorobots/softhand/#about","text":"","title":"About"},{"location":"sorobots/softhand/#fabrication-details","text":"The soft hand is fully printable. Below, we provided a list of the printer materials. 4 \\(\\times\\) : Soft Finger - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Soft Thumb - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Finger Connector - Rigid 10k - Formlabs (recommended) 1 \\(\\times\\) : Rigid Palm - Prusament PLA White - Prusa (optional) 1 \\(\\times\\) : Rigid Base - Prusament PLA White - Prusa (optional) Printing of Elastic 80A When printing Elastic 80A, the recommended supports for the material are very thick -- thus difficult to remove. We recommend generating the supports using Rigid 10K , then change the material to Elastic 80A . Support can then be easily removed manually (no pliers required). Cleaning and closing of Soft Actuators A crucial step is cleaning of the elastic resin parts. If residual resin is not properly removed/cleaned, it will greatly affect the quality and performance of the soft actuator. We recommend following the cleaning procedures proposed in Proper et al. [^1], see Git documentation . The paper draft can be found here: Paper.pdf . In their approach, a perastaltic pump is used to pump cleaning fluid through the soft actuator prior to curing. To allow fluid to flow, both sides of the soft actuator are open! They must be closed using 3 mm plug printed from the same material! The plug can be glued in place using uncured resin, and then placed in an UV chamber for a short duration. Connecting Soft Actuator to Rigid Connector Similar to closing of the soft actuators, uncured resin can be used to make a robust connection to the rigid pressure connector. This greatly improves air-tightness of the complete system.","title":"Fabrication details"},{"location":"sorobots/softhand/#downloadable-content","text":"Complete Soft Robot Hand - uncompressed 14.3 MB (zip) Rigid Palm (STL) Rigid Base (STL) Finger Connector (STL) Soft Finger(s) (STL) Soft Thumb (STL)","title":"Downloadable content"},{"location":"sorobots/softhand/#3d-visualization","text":"var iframe = document.getElementById( 'api-frame' ); var uid = 'f8ffac8550114147bf9483dd2c8edb72'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } );","title":"3D Visualization"},{"location":"sorobots/softmanipulator/","text":"Soft Manipulator About Fabrication details The soft manipulator is fully printable. Below, we provided a list of the printer materials. 1 \\(\\times\\) : Soft Bellow - Elastic 80A - Formlabs (recommended) 3 \\(\\times\\) : Soft Finger - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Connector One-way - Rigid 10k - Formlabs (optional) 1 \\(\\times\\) : Connector Three-way - Rigid 10k - Formlabs (optional) 1 \\(\\times\\) : Base mount M6 - Prusament PLA Azure - Prusa (optional) Printing of Elastic 80A When printing Elastic 80A, the recommended supports for the material are very thick -- thus difficult to remove. We recommend generating the supports using Rigid 10K , then change the material to Elastic 80A . Support can then be easily removed manually (no pliers required). Cleaning and closing of Soft Actuators A crucial step is cleaning of the elastic resin parts. If residual resin is not properly removed/cleaned, it will greatly affect the quality and performance of the soft actuator. We recommend following the cleaning procedures proposed in Proper et al. 1 , see Git documentation . The paper draft can be found here: Paper.pdf . In their approach, a perastaltic pump is used to pump cleaning fluid through the soft actuator prior to curing. To allow fluid to flow, both sides of the soft actuator are open! They must be closed using 3 mm plug printed from the same material! The plug can be glued in place using uncured resin, and then placed in an UV chamber for a short duration. Connecting Soft Actuator to Rigid Connector Similar to closing of the soft actuators, uncured resin can be used to make a robust connection to the rigid pressure connector. This greatly improves air-tightness of the complete system. Downloadable content Complete Soft Robot Manipulator - 14.6 MB uncompressed (.zip) Soft Bellow (STL) Soft Finger (STL) Connector One-way (STL) Connector Three-way (STL) Base mount M6 (STL) 3D Visualization var iframe = document.getElementById( 'api-frame' ); var uid = '3fd62289149f4145856b9c664c033917'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } ); Proper. B, Caasenbrood, B., & I. Kuling (2023). Easy Cleaning of 3D SLA/DLP Printed Soft Fluidic Actuators with Complex Internal Geometry. 6th IEEE International Conference on Soft Robotics, RoboSoft 2023. (submitted). https://github.com/ReshapeTUe/Peristaltic-Pump-Documentation \u21a9","title":"Soft Manipulator"},{"location":"sorobots/softmanipulator/#soft-manipulator","text":"","title":"Soft Manipulator"},{"location":"sorobots/softmanipulator/#about","text":"","title":"About"},{"location":"sorobots/softmanipulator/#fabrication-details","text":"The soft manipulator is fully printable. Below, we provided a list of the printer materials. 1 \\(\\times\\) : Soft Bellow - Elastic 80A - Formlabs (recommended) 3 \\(\\times\\) : Soft Finger - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Connector One-way - Rigid 10k - Formlabs (optional) 1 \\(\\times\\) : Connector Three-way - Rigid 10k - Formlabs (optional) 1 \\(\\times\\) : Base mount M6 - Prusament PLA Azure - Prusa (optional) Printing of Elastic 80A When printing Elastic 80A, the recommended supports for the material are very thick -- thus difficult to remove. We recommend generating the supports using Rigid 10K , then change the material to Elastic 80A . Support can then be easily removed manually (no pliers required). Cleaning and closing of Soft Actuators A crucial step is cleaning of the elastic resin parts. If residual resin is not properly removed/cleaned, it will greatly affect the quality and performance of the soft actuator. We recommend following the cleaning procedures proposed in Proper et al. 1 , see Git documentation . The paper draft can be found here: Paper.pdf . In their approach, a perastaltic pump is used to pump cleaning fluid through the soft actuator prior to curing. To allow fluid to flow, both sides of the soft actuator are open! They must be closed using 3 mm plug printed from the same material! The plug can be glued in place using uncured resin, and then placed in an UV chamber for a short duration. Connecting Soft Actuator to Rigid Connector Similar to closing of the soft actuators, uncured resin can be used to make a robust connection to the rigid pressure connector. This greatly improves air-tightness of the complete system.","title":"Fabrication details"},{"location":"sorobots/softmanipulator/#downloadable-content","text":"Complete Soft Robot Manipulator - 14.6 MB uncompressed (.zip) Soft Bellow (STL) Soft Finger (STL) Connector One-way (STL) Connector Three-way (STL) Base mount M6 (STL)","title":"Downloadable content"},{"location":"sorobots/softmanipulator/#3d-visualization","text":"var iframe = document.getElementById( 'api-frame' ); var uid = '3fd62289149f4145856b9c664c033917'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } ); Proper. B, Caasenbrood, B., & I. Kuling (2023). Easy Cleaning of 3D SLA/DLP Printed Soft Fluidic Actuators with Complex Internal Geometry. 6th IEEE International Conference on Soft Robotics, RoboSoft 2023. (submitted). https://github.com/ReshapeTUe/Peristaltic-Pump-Documentation \u21a9","title":"3D Visualization"}]}