{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sorotoki - a MATLAB toolkit for soft robotics Github page is still under construction. Not all documentation is present at the this stage of development. Sorotoki is an open-source MATLAB toolkit for soft robotics that aims to facilitate the development of novel research in the field by providing a comprehensive set of tools for design, modeling, and control. The toolkit includes a diverse array of scientific disciplines relevant to soft robotics, such as continuum mechanics, dynamic systems and control theory, topology optimization, and computer graphics. The Sorotoki toolkit aims to make it easier for new researchers to learn about soft robotics by providing a range of tools that cover various important aspects of the field. This can significantly reduce the amount of time and effort required to get up to speed on the topic. What can Sorotoki do? Sorotoki has grown significantly since its inception and now offers a wide range of functionalities tailored to various aspects of soft robotics. For example, suppose you are inspired by the multi-gait soft crawler developed by Shepard et al. 1 -- See video . Or you want to simulate the incredibly dexterous soft gripper developed by Suzumori et al. 2 -- See video . Can we model such systems easily? Well.... Short answer: no . As matter of fact, simplifying the (infinite-dimensional) dynamics of soft robots is no easy feat. It has been an active topic of research for the better part of the last two decades. Ironically, studying \"soft\" robotics is incredibly \"hard\" . Sorotoki, however, can simplify the process of design, modeling and control for soft robots. Our aim is to make research into soft robotics more accessable by dividing the problem into smaller, more manageable steps. Multi-physics solvers are included into Sorotoki and can accessed with minimal programming complexity. Simulation of multi-gait crawling soft robot undergoing an undulating motion. The model is inspired by the work of Shepard et al. (2011). Original soft robot can be found here: Youtube video Simulation of multi-finger soft gripper grasping a beaker and manipulating a M10 boltscrew. The model is inspired by the work of Suzumori et al. (1989). Original soft gripper can be found here: Youtube video But, is it easy to code? Well, absolutely! Sorotoki is aimed at removing complexity -- not only for soft robots but also for coding your problems! See the following example codes below: Code for multi-gait soft crawler: Locomotion example Code for multi-finger soft gripper (beaker): Grasping example and Object manipulation example List of functionalities To summarize, some of the functionalities included in the toolkit are listed below: Design: Implicit modeling using signed distance functions (SDFs), 2D-3D mesh generation, computational design using gradient-based optimization Modeling: Finite Element Models (FEM), high-efficiency reduced-order soft beam models (Lagrangian or port-Hamiltonian), easy programmable interconnections of a network of dynamical (soft robot) systems Control: Real-time (pneumatic) control platform using Raspberry Pi, vision-based sensing algorithms using Intel Realsense Depth camera Visualization: Fast and responsive 3D graphics rendering, mesh deformation modifiers (scaling, rotation, bending, twisting, mirroring), Forward Kinematic/Inverse Kinematic-rigging Accessibility: Minimal programming environment (i.e, focused on expressing complex problems with minimal lines of code). Open hardware: Four 3D-printable soft robots (e.g., soft hand, soft manipulator), and control interface). Short examples Example 1: PneuNet deformations A classic example in soft robotics is the PneuNet soft bending actuator. The PneuNet (pneumatic network) belongs to a class of soft actuators that, due to a geometrically induced stiffness differential, undergoes bending when pressurized. The geometry of the PneuNet is developed (and popularized) by Mosadegh et al. 3 , but historically it is much older 4 . To model the PneuNet actuator, consider the following numerical example. Assuming plane strain , we can simulate the nonlinear bending characteristics of the Pneunet actuator using the super-short code below (only 10 lines of code!): Code for simulation % generate mesh from image msh = preset . mesh . pneunet ; % finite element solver (FEM) fem = Fem ( msh , 'TimeStep' , 1e-2 ); % boundary conditions fem = fem . addMaterial ( NeoHookean ( 1 , 0.4 )); fem = fem . addGravity (); fem = fem . addPressure ( 'AllHole' , 30 * 1e-3 ); fem = fem . addSupport ( 'Left' , [ 1 , 1 ]); % magic fem = fem . solve (); % take away message: simplicity > complexity Code for plotting Once a simulation is completed, there exist simple command to export the simulation as a .gif file. We can simple use the command below. This sets the frames-per-second (FPS), the axis for the replay video, and gif = true to make a gif file. fem . replay ( 'fps' , 60 , ... 'axis' ,[ - 33 , 120 - 86 21 ], ... 'gif' , true ) Example 2: Fitting hyper-elastic materials Soft robots own their name to soft materials. It is therefore of paramount importance that the constitutive material models reflect the mechanical nature truthfully. However, finding the \" true \" material parameters for these material models can be challenging without the proper tools. Sorotoki is equipped with tools for hyper-elastic material fitting. Consider for instance the cubic Yeoh model: \\[ \\Psi_{\\textrm{YH}}(I_1; \\pi) = \\sum_{i = 1}^3 \\pi_i (I_1 - 3)^{i} \\] where \\(I_1 = {\\lambda_1}^2 + {\\lambda_2}^2 + {\\lambda_3}^2\\) is the first strain invariant, and \\(\\pi\\) a vector of unknown material parameters. For uniaxial tension, we have that \\(\\lambda_1 = \\lambda\\) and \\(\\lambda_2 = \\lambda_3 = 1/{\\lambda^2}\\) . Therefore, the stress along the uniaxial tension test is given by \\( \\sigma_{11} = 2 \\left(\\lambda^2 - \\frac{1}{\\lambda} \\right)\\Psi' \\) with \\(\\Psi'\\) the partial derivative of \\(\\Psi\\) with respect to \\(I_1\\) . Luckily, these uniaxial stress-strain relations are included in every hyperelastic material model of Sorotoki. Simply call S = material.uniaxial(x) . The optimal material parameters \\(\\pi\\) can then be easily found using standard optimization routines such as fmincon . See the example below. Code for simulation % CODE: Example 2 -- Material fitting using fmincon [ lam , str ] = materialDataBase ( 'DragonSkin10' ); % define objective (Yeoh model) obj = @( Pi ) Objective ( Pi , lam , str ); Pi0 = [ 0.0 , 0.0 , 0.0 ]; % initial guess lb = [ 1e-6 , - 2 , - 2 ]; % lower bounds ub = [ Inf , Inf , Inf ]; % upper bounds opt = optimoptions (@ fmincon , 'FiniteDifferenceStepSize' , 1e-12 , 'Algorithm' , 'sqp-legacy' ); fig ( 101 ,[ 9 , 9 ]); Pi = fmincon ( Obj , Pi0 ,[],[],[],[], lb , ub ,[], opt ); function obj = Objective ( Pi,X,Y ) Q = diag ( Y .^- 2 ); % weighting - emphasis low strains E = Y - YeohMaterial ( Pi ). uniaxial ( X ); % stress resid. % quadratic lost function obj = E (:). ' * Q * E (:); cla ; plot ( x , y , 'Color' , color_light_gray ); hold on ; plot ( x , YeohMaterial ( Pi ). uniaxial ( x ), ... 'Color' , color_visited_alt ); ylabel ( 'engineering stress $\\sigma_{11}$' ); xlabel ( 'stretch $\\lambda$' ); end Example 3: Task-space controller for soft manipulator The next example shows the implementation of model-based controllers in Sorotoki. Consider a soft tentacle of length \\(L = 100\\) mm, radius \\(R = 5\\) mm, and a tapering of \\(75\\%\\) . We assume the tentacle is composed of DragonSkin10A silicone. \\[\\tau = J_v^\\top\\left[k_p (X_d - X) - k_d \\dot{X}\\right] + \\nabla_q \\mathcal{V}\\] where \\(J_v(q) := \\lfloor J(q,L) \\rfloor_3\\) is the linear velocity part of the manipulator Jacobian matrix at the tip ( \\(\\sigma = L\\) ), \\(\\nabla_q \\mathcal{V}\\) is simply the gradient of the potential energy w.r.t to its states \\(q\\) , \\(X\\) and \\(X_d\\) the end-effector position and the desired position, respectively. Note that we can compute the end-effector velocity by \\(\\dot{X} = J_v(q) \\dot{q}\\) . Code for simulation % CODE: Example 2 -- Task-space controller % assign desired setpoint Xd = [ 30 ; 10 ; 10 ]; % build continuum shape POD = chebyspace ( 60 , 3 ); % POD basis shp = Shapes ( POD ,[ 0 , 3 , 3 , 0 , 0 , 0 ], ... % pure bending XY 'Length' , 100 , ... 'Material' , Dragonskin10 ); % geometry and boundary conditions shp = shp . setRadius ( 5 ); % R = 5 mm shp = shp . setRamp ( 0.75 ); % R is reduced by 75% at s=L shp = shp . addGravity (); % model composer mdl = Model ( shp , 'TimeStep' , 1 / 60 , ... 'Controller' , @( x ) tau ( x , Xd ) ); % magic ;) mdl = mdl . simulate (); % task-space controller (called by solver) function tau = tau ( mdl,Xd ) log = mdl . Systems { 1 }. Log ; X = log . FK . g ( 1 : 3 , 4 , end ); Jv = log . FK . J ( 4 : 6 ,:, end ); Vq = log . PH . dVdq ; tau = Jv . '* ( 1e-3 * ( Xd - X ) - 1e-4 * Jv * log . dq ) + Vq ; end Code for plotting % Example 2b: plotting Model data % for loop over Model log files for ii = 1 : numel ( mdl . Log . t ) shp = shp . render ( mdl . Log . x ( ii , 1 : 6 )); % render shape if ii == 1 , % render setpoint Xd plotpoint ( Xd ); end axis ([ 0 100 - 5 , 5 , - 10 , 30 ]); view ( 30 , 30 ); drawnow ; end Example 4: Open-loop control of soft hand % CODE: Example 3 -- Open-loop controller % connect to controller board brd = Bdog ( 'pi' , '192.168.0.2' , 'pwd' , ... 'NVeab' , 3 ); % set board update frequency brd = brd . set ( 'Frequency' , 120 ); % phase offset per finger phi = @( k ) ( k - 1 ) * pi / 6 ; %% execute control loop for T=10s while brd . loop ( 10 ) T = ones ( 5 , 1 ) * brd . t ; Pd = zeros ( 1 , 6 ); Pd ( 1 : 5 ) = 80 * sign ( sin ( 4 * T - phi ( 1 : 5 ). ' )) * ... smoothstep ( t - 1 ); brd . setInput ( Pd ); end % disconnect system brd . disconnect (); How to cite? If you are planning on using Sorotoki in your (academic) work, please consider citing the toolkit @misc { Caasenbrood2020 , author = {Caasenbrood, Brandon} , title = {Sorotoki - A Soft Robotics Toolkit for MATLAB} , year = {2020} , publisher = {GitHub} , journal = {GitHub repository} , howpublished = {\\url{https://github.com/BJCaasenbrood/SorotokiCode}} , } Shepherd, R. F., Ilievski, F., Choi, W., Morin, S. A., Stokes, A. A., Mazzeo, A. D., ...Whitesides, G. M. (2011). Multigait soft robot. Proc. Natl. Acad. Sci. U.S.A., 22123978. Retrieved from https://pubmed.ncbi.nlm.nih.gov/22123978 doi: https://doi.org/10.1073/pnas.1116564108 \u21a9 Suzumori, K., Iikura, S., & Tanaka, H. (1991). Development of flexible microactuator and its applications to robotic mechanisms. Proceedings. 1991 IEEE International Conference on Robotics and Automation. IEEE. doi: https://doi.org/10.1109/ROBOT.1991.131850 \u21a9 Mosadegh, B., Polygerinos, P., Keplinger, C., Wennstedt, S., Shepherd, R. F., Gupta, U., ...Whitesides, G. M. (2014). Pneumatic Networks for Soft Robotics that Actuate Rapidly. Adv. Funct. Mater., 24(15), 2163\u20132170. doi: https://doi.org/10.1002/adfm.201303288 \u21a9 1981 - Robot Arm with Pneumatic Gripper - Nikolai Teleshev (Russian) - cyberneticzoo.com. (2012, April 08). Retrieved from http://cyberneticzoo.com/bionics/1981-robot-arm-with-pneumatic-gripper-nikolai-teleshev-russian \u21a9","title":"Sorotoki - a MATLAB toolkit for soft robotics"},{"location":"#sorotoki-a-matlab-toolkit-for-soft-robotics","text":"Github page is still under construction. Not all documentation is present at the this stage of development. Sorotoki is an open-source MATLAB toolkit for soft robotics that aims to facilitate the development of novel research in the field by providing a comprehensive set of tools for design, modeling, and control. The toolkit includes a diverse array of scientific disciplines relevant to soft robotics, such as continuum mechanics, dynamic systems and control theory, topology optimization, and computer graphics. The Sorotoki toolkit aims to make it easier for new researchers to learn about soft robotics by providing a range of tools that cover various important aspects of the field. This can significantly reduce the amount of time and effort required to get up to speed on the topic.","title":"Sorotoki - a MATLAB toolkit for soft robotics"},{"location":"#what-can-sorotoki-do","text":"Sorotoki has grown significantly since its inception and now offers a wide range of functionalities tailored to various aspects of soft robotics. For example, suppose you are inspired by the multi-gait soft crawler developed by Shepard et al. 1 -- See video . Or you want to simulate the incredibly dexterous soft gripper developed by Suzumori et al. 2 -- See video . Can we model such systems easily? Well.... Short answer: no . As matter of fact, simplifying the (infinite-dimensional) dynamics of soft robots is no easy feat. It has been an active topic of research for the better part of the last two decades. Ironically, studying \"soft\" robotics is incredibly \"hard\" . Sorotoki, however, can simplify the process of design, modeling and control for soft robots. Our aim is to make research into soft robotics more accessable by dividing the problem into smaller, more manageable steps. Multi-physics solvers are included into Sorotoki and can accessed with minimal programming complexity. Simulation of multi-gait crawling soft robot undergoing an undulating motion. The model is inspired by the work of Shepard et al. (2011). Original soft robot can be found here: Youtube video Simulation of multi-finger soft gripper grasping a beaker and manipulating a M10 boltscrew. The model is inspired by the work of Suzumori et al. (1989). Original soft gripper can be found here: Youtube video But, is it easy to code? Well, absolutely! Sorotoki is aimed at removing complexity -- not only for soft robots but also for coding your problems! See the following example codes below: Code for multi-gait soft crawler: Locomotion example Code for multi-finger soft gripper (beaker): Grasping example and Object manipulation example","title":"What can Sorotoki do?"},{"location":"#list-of-functionalities","text":"To summarize, some of the functionalities included in the toolkit are listed below: Design: Implicit modeling using signed distance functions (SDFs), 2D-3D mesh generation, computational design using gradient-based optimization Modeling: Finite Element Models (FEM), high-efficiency reduced-order soft beam models (Lagrangian or port-Hamiltonian), easy programmable interconnections of a network of dynamical (soft robot) systems Control: Real-time (pneumatic) control platform using Raspberry Pi, vision-based sensing algorithms using Intel Realsense Depth camera Visualization: Fast and responsive 3D graphics rendering, mesh deformation modifiers (scaling, rotation, bending, twisting, mirroring), Forward Kinematic/Inverse Kinematic-rigging Accessibility: Minimal programming environment (i.e, focused on expressing complex problems with minimal lines of code). Open hardware: Four 3D-printable soft robots (e.g., soft hand, soft manipulator), and control interface).","title":"List of functionalities"},{"location":"#short-examples","text":"Example 1: PneuNet deformations A classic example in soft robotics is the PneuNet soft bending actuator. The PneuNet (pneumatic network) belongs to a class of soft actuators that, due to a geometrically induced stiffness differential, undergoes bending when pressurized. The geometry of the PneuNet is developed (and popularized) by Mosadegh et al. 3 , but historically it is much older 4 . To model the PneuNet actuator, consider the following numerical example. Assuming plane strain , we can simulate the nonlinear bending characteristics of the Pneunet actuator using the super-short code below (only 10 lines of code!): Code for simulation % generate mesh from image msh = preset . mesh . pneunet ; % finite element solver (FEM) fem = Fem ( msh , 'TimeStep' , 1e-2 ); % boundary conditions fem = fem . addMaterial ( NeoHookean ( 1 , 0.4 )); fem = fem . addGravity (); fem = fem . addPressure ( 'AllHole' , 30 * 1e-3 ); fem = fem . addSupport ( 'Left' , [ 1 , 1 ]); % magic fem = fem . solve (); % take away message: simplicity > complexity Code for plotting Once a simulation is completed, there exist simple command to export the simulation as a .gif file. We can simple use the command below. This sets the frames-per-second (FPS), the axis for the replay video, and gif = true to make a gif file. fem . replay ( 'fps' , 60 , ... 'axis' ,[ - 33 , 120 - 86 21 ], ... 'gif' , true ) Example 2: Fitting hyper-elastic materials Soft robots own their name to soft materials. It is therefore of paramount importance that the constitutive material models reflect the mechanical nature truthfully. However, finding the \" true \" material parameters for these material models can be challenging without the proper tools. Sorotoki is equipped with tools for hyper-elastic material fitting. Consider for instance the cubic Yeoh model: \\[ \\Psi_{\\textrm{YH}}(I_1; \\pi) = \\sum_{i = 1}^3 \\pi_i (I_1 - 3)^{i} \\] where \\(I_1 = {\\lambda_1}^2 + {\\lambda_2}^2 + {\\lambda_3}^2\\) is the first strain invariant, and \\(\\pi\\) a vector of unknown material parameters. For uniaxial tension, we have that \\(\\lambda_1 = \\lambda\\) and \\(\\lambda_2 = \\lambda_3 = 1/{\\lambda^2}\\) . Therefore, the stress along the uniaxial tension test is given by \\( \\sigma_{11} = 2 \\left(\\lambda^2 - \\frac{1}{\\lambda} \\right)\\Psi' \\) with \\(\\Psi'\\) the partial derivative of \\(\\Psi\\) with respect to \\(I_1\\) . Luckily, these uniaxial stress-strain relations are included in every hyperelastic material model of Sorotoki. Simply call S = material.uniaxial(x) . The optimal material parameters \\(\\pi\\) can then be easily found using standard optimization routines such as fmincon . See the example below. Code for simulation % CODE: Example 2 -- Material fitting using fmincon [ lam , str ] = materialDataBase ( 'DragonSkin10' ); % define objective (Yeoh model) obj = @( Pi ) Objective ( Pi , lam , str ); Pi0 = [ 0.0 , 0.0 , 0.0 ]; % initial guess lb = [ 1e-6 , - 2 , - 2 ]; % lower bounds ub = [ Inf , Inf , Inf ]; % upper bounds opt = optimoptions (@ fmincon , 'FiniteDifferenceStepSize' , 1e-12 , 'Algorithm' , 'sqp-legacy' ); fig ( 101 ,[ 9 , 9 ]); Pi = fmincon ( Obj , Pi0 ,[],[],[],[], lb , ub ,[], opt ); function obj = Objective ( Pi,X,Y ) Q = diag ( Y .^- 2 ); % weighting - emphasis low strains E = Y - YeohMaterial ( Pi ). uniaxial ( X ); % stress resid. % quadratic lost function obj = E (:). ' * Q * E (:); cla ; plot ( x , y , 'Color' , color_light_gray ); hold on ; plot ( x , YeohMaterial ( Pi ). uniaxial ( x ), ... 'Color' , color_visited_alt ); ylabel ( 'engineering stress $\\sigma_{11}$' ); xlabel ( 'stretch $\\lambda$' ); end Example 3: Task-space controller for soft manipulator The next example shows the implementation of model-based controllers in Sorotoki. Consider a soft tentacle of length \\(L = 100\\) mm, radius \\(R = 5\\) mm, and a tapering of \\(75\\%\\) . We assume the tentacle is composed of DragonSkin10A silicone. \\[\\tau = J_v^\\top\\left[k_p (X_d - X) - k_d \\dot{X}\\right] + \\nabla_q \\mathcal{V}\\] where \\(J_v(q) := \\lfloor J(q,L) \\rfloor_3\\) is the linear velocity part of the manipulator Jacobian matrix at the tip ( \\(\\sigma = L\\) ), \\(\\nabla_q \\mathcal{V}\\) is simply the gradient of the potential energy w.r.t to its states \\(q\\) , \\(X\\) and \\(X_d\\) the end-effector position and the desired position, respectively. Note that we can compute the end-effector velocity by \\(\\dot{X} = J_v(q) \\dot{q}\\) . Code for simulation % CODE: Example 2 -- Task-space controller % assign desired setpoint Xd = [ 30 ; 10 ; 10 ]; % build continuum shape POD = chebyspace ( 60 , 3 ); % POD basis shp = Shapes ( POD ,[ 0 , 3 , 3 , 0 , 0 , 0 ], ... % pure bending XY 'Length' , 100 , ... 'Material' , Dragonskin10 ); % geometry and boundary conditions shp = shp . setRadius ( 5 ); % R = 5 mm shp = shp . setRamp ( 0.75 ); % R is reduced by 75% at s=L shp = shp . addGravity (); % model composer mdl = Model ( shp , 'TimeStep' , 1 / 60 , ... 'Controller' , @( x ) tau ( x , Xd ) ); % magic ;) mdl = mdl . simulate (); % task-space controller (called by solver) function tau = tau ( mdl,Xd ) log = mdl . Systems { 1 }. Log ; X = log . FK . g ( 1 : 3 , 4 , end ); Jv = log . FK . J ( 4 : 6 ,:, end ); Vq = log . PH . dVdq ; tau = Jv . '* ( 1e-3 * ( Xd - X ) - 1e-4 * Jv * log . dq ) + Vq ; end Code for plotting % Example 2b: plotting Model data % for loop over Model log files for ii = 1 : numel ( mdl . Log . t ) shp = shp . render ( mdl . Log . x ( ii , 1 : 6 )); % render shape if ii == 1 , % render setpoint Xd plotpoint ( Xd ); end axis ([ 0 100 - 5 , 5 , - 10 , 30 ]); view ( 30 , 30 ); drawnow ; end Example 4: Open-loop control of soft hand % CODE: Example 3 -- Open-loop controller % connect to controller board brd = Bdog ( 'pi' , '192.168.0.2' , 'pwd' , ... 'NVeab' , 3 ); % set board update frequency brd = brd . set ( 'Frequency' , 120 ); % phase offset per finger phi = @( k ) ( k - 1 ) * pi / 6 ; %% execute control loop for T=10s while brd . loop ( 10 ) T = ones ( 5 , 1 ) * brd . t ; Pd = zeros ( 1 , 6 ); Pd ( 1 : 5 ) = 80 * sign ( sin ( 4 * T - phi ( 1 : 5 ). ' )) * ... smoothstep ( t - 1 ); brd . setInput ( Pd ); end % disconnect system brd . disconnect ();","title":"Short examples"},{"location":"#how-to-cite","text":"If you are planning on using Sorotoki in your (academic) work, please consider citing the toolkit @misc { Caasenbrood2020 , author = {Caasenbrood, Brandon} , title = {Sorotoki - A Soft Robotics Toolkit for MATLAB} , year = {2020} , publisher = {GitHub} , journal = {GitHub repository} , howpublished = {\\url{https://github.com/BJCaasenbrood/SorotokiCode}} , } Shepherd, R. F., Ilievski, F., Choi, W., Morin, S. A., Stokes, A. A., Mazzeo, A. D., ...Whitesides, G. M. (2011). Multigait soft robot. Proc. Natl. Acad. Sci. U.S.A., 22123978. Retrieved from https://pubmed.ncbi.nlm.nih.gov/22123978 doi: https://doi.org/10.1073/pnas.1116564108 \u21a9 Suzumori, K., Iikura, S., & Tanaka, H. (1991). Development of flexible microactuator and its applications to robotic mechanisms. Proceedings. 1991 IEEE International Conference on Robotics and Automation. IEEE. doi: https://doi.org/10.1109/ROBOT.1991.131850 \u21a9 Mosadegh, B., Polygerinos, P., Keplinger, C., Wennstedt, S., Shepherd, R. F., Gupta, U., ...Whitesides, G. M. (2014). Pneumatic Networks for Soft Robotics that Actuate Rapidly. Adv. Funct. Mater., 24(15), 2163\u20132170. doi: https://doi.org/10.1002/adfm.201303288 \u21a9 1981 - Robot Arm with Pneumatic Gripper - Nikolai Teleshev (Russian) - cyberneticzoo.com. (2012, April 08). Retrieved from http://cyberneticzoo.com/bionics/1981-robot-arm-with-pneumatic-gripper-nikolai-teleshev-russian \u21a9","title":"How to cite?"},{"location":"contact/","text":"Developer(s) Almost 4,5 years ago, Sorotoki began as a minuscule Matlab folder called librarySoftRobotics . As a starting PhD student, the trenches of the field of soft robotics ran deep and far. Very quickly, the folder grew and grew -- and it was slowly becoming an unorganized mess. The main problem stemmed (and still stems) from its multidisciplinary nature -- each Matlab script solved \"one\" and \"non-generalizable\" solution. There was no cross-compatibility between the code... As a solution, I began collecting my code into one compact toolkit called: Sorotoki -- short for So ft Ro botics To ol Ki t. Main developer Email Google Scholar Github Discord Brandon Caasenbrood works as a Ph.D. candidate in the Dynamics and Control group within the Mechanical Engineering department. He is currently involved in the Wearable Robotics perspective program, which explores soft robotics -- a subfield of robotics where rigid materials are substituted for softer alternatives. Naturally, these systems have major human-robot safety benefits relevant to wearable robotics. Besides, their intrinsic softness allows for higher-degree mobility that is difficult to achieve in their rigid counterparts. The main inspiration for soft robots stems from biology, with the aim of achieving similar performance and dexterity as biological creatures. Although the field has made significant steps have been towards bridging biology and robotics, its innate infinite dimensionality poses substantial challenges on design, modeling, and control. The diligence of achieving similar precision and speed to nowadays\u2019 rigid robots, and ultimately nature, stresses the paramount importance of novel engineering strategies tailored for soft robotics. His research tackles the problems within the design and control of these soft robots by exploring first principle methods. His interest lies in the computational design of continuum structure, nonlinear dynamics, and model-based control in the context of bio\u2011inspired soft robots. The emphasis here is on bridging the gaps between nature and robotics on a hardware and software level.","title":"Developer(s)"},{"location":"contact/#developers","text":"Almost 4,5 years ago, Sorotoki began as a minuscule Matlab folder called librarySoftRobotics . As a starting PhD student, the trenches of the field of soft robotics ran deep and far. Very quickly, the folder grew and grew -- and it was slowly becoming an unorganized mess. The main problem stemmed (and still stems) from its multidisciplinary nature -- each Matlab script solved \"one\" and \"non-generalizable\" solution. There was no cross-compatibility between the code... As a solution, I began collecting my code into one compact toolkit called: Sorotoki -- short for So ft Ro botics To ol Ki t. Main developer Email Google Scholar Github Discord Brandon Caasenbrood works as a Ph.D. candidate in the Dynamics and Control group within the Mechanical Engineering department. He is currently involved in the Wearable Robotics perspective program, which explores soft robotics -- a subfield of robotics where rigid materials are substituted for softer alternatives. Naturally, these systems have major human-robot safety benefits relevant to wearable robotics. Besides, their intrinsic softness allows for higher-degree mobility that is difficult to achieve in their rigid counterparts. The main inspiration for soft robots stems from biology, with the aim of achieving similar performance and dexterity as biological creatures. Although the field has made significant steps have been towards bridging biology and robotics, its innate infinite dimensionality poses substantial challenges on design, modeling, and control. The diligence of achieving similar precision and speed to nowadays\u2019 rigid robots, and ultimately nature, stresses the paramount importance of novel engineering strategies tailored for soft robotics. His research tackles the problems within the design and control of these soft robots by exploring first principle methods. His interest lies in the computational design of continuum structure, nonlinear dynamics, and model-based control in the context of bio\u2011inspired soft robots. The emphasis here is on bridging the gaps between nature and robotics on a hardware and software level.","title":"Developer(s)"},{"location":"install/","text":"Installation The toolkit is easy to install. The fastest and easiest way to acquire the toolkit is through mpm (Matlab Package Manager). mpm is a simple package manager for Matlab (inspired by pip ) and downloads packages from Matlab Central's File Exchange, GitHub repositories, or any other url pointing to a .zip file. Prerequisite toolboxes of MATLAB To use Sorotoki, make sure you have the following dependencies installed: Optimization Toolbox Partial Differential Equation Toolbox Image Processing Toolbox Matlab Coder Prerequisite software for Sorotoki (upon install of Sorotoki with MPM) To use Sorotoki, following community packages are required: Matlab Essentials Kit Matlab Progressbar Matlab Graphical Model interparc distance2curve inpolyhedron Installation via Matlab Package Manager (MPM) The toolkit is easy to install. The fastest and easiest way to acquire the toolkit is through mpm (Matlab Package Manager). mpm is a simple package manager for Matlab (inspired by pip ) and downloads packages from Matlab Central's File Exchange, GitHub repositories, or any other url pointing to a .zip file. Step 1: Downloading Sorotoki using MPM Install on mpm-package: You can directly clone the repository using the MPM command: mpm install sorotokicode -- all - paths This command will download SorotokiCode directly from the GitHub repository and create the SorotokiCode folder in the ./mpm-package folder. Installing in specified folder Install on desired location: Alternatively, the installation folder can be set to ~./Documents/MATLAB/ . This is done by running the following line: mpm install sorotokicode - d ~./ Documents / MATLAB / -- all - paths Error using mpm: This command is not supported when the mpm feature is not enabled. This error is due to the fact that MATLAB has its own function called mpm , which is in conflict with the mpm tools written by mobeets . To solve the issue, we can generate a file under ~./Documents/MATLAB called startup.m . This file is called during the startup of MATLAB, and will addpath of the mobeets-mpm folder. ./Documents/MATLAB/startup.m warning off % change USER to your username! USER = 'johndoe' ; if ispc addpath ([ 'C:\\Users\\' , USER , '\\AppData\\Roaming\\MathWorks\\,... ' \\ MATLAB Add - Ons \\ Collections / mpm / mobeets - mpm - c626429 ' ]); elseif isunix addpath ([ '/home/' , USER , '/MATLAB Add-Ons/Collections/mpm/mobeets-mpm-c626429' ]); end mpm init clc ; warning on Step 2: Running the installer After ensuring that all the necessary prerequisites are correctly installed, the next step involves configuring the toolkit with MATLAB's search paths. This process is relatively straightforward and can be accomplished by executing the following command: sorotoki cd % navigate to install folder sorotoki install -- approve % run installer (with auto approve) The toolkit will proceed with the installation by building search paths in Matlab. The toolkit will request the installation of the prerequisite toolboxes if they are not already installed. These include: Optimization Toolbox, Partial Differential Equation Toolbox, Image Processing Toolbox, and Matlab Coder. Especially the latter ensures that embedded Sorotoki functions can be converted to c or c++ equivalent code in the form of mex files, which greatly enhances computational performance. Finally, a verification routine is performed to check if the toolkit is installed correctly. Step 3: Building the toolkit Since Sorotoki uses the MATLAB Coder toolbox to speed-up computation, the toolkit still needs to be build. Here, MATLAB functions are converted to c++ executables that can be called from MATLAB as .mex files. To build these .mex files, we can simply call sorotoki build -- approve % build sorotoki executables Step 4: That's it folks And that's it, Sorotoki is now ready to use. The sorotoki installation command can also be used to run demo, check updates, see version number, and find the documentation file. You can do these by running the following commands: sorotoki demo % list demos sorotoki d % ... sorotoki version % version (and do i need to update?) sorotoki v % ... sorotoki doc % documentation link sorotoki i % ... Manual installation Alternatively, you can download the latest version of the toolkit below, and unpack the compressed folder at any desired working directory. We do not recommend this procedure, as MPM can help maintain the Sorotoki toolkit if future updates may appear. Sorotoki v.3.0.0.stable (code) FAQ and installation issues Darn', other problems during installation Please let me know by: Post an issue at: https://github.com/BJCaasenbrood/SorotokiCode/issues Get help directly at our Discord server","title":"Installation"},{"location":"install/#installation","text":"The toolkit is easy to install. The fastest and easiest way to acquire the toolkit is through mpm (Matlab Package Manager). mpm is a simple package manager for Matlab (inspired by pip ) and downloads packages from Matlab Central's File Exchange, GitHub repositories, or any other url pointing to a .zip file. Prerequisite toolboxes of MATLAB To use Sorotoki, make sure you have the following dependencies installed: Optimization Toolbox Partial Differential Equation Toolbox Image Processing Toolbox Matlab Coder Prerequisite software for Sorotoki (upon install of Sorotoki with MPM) To use Sorotoki, following community packages are required: Matlab Essentials Kit Matlab Progressbar Matlab Graphical Model interparc distance2curve inpolyhedron","title":"Installation"},{"location":"install/#installation-via-matlab-package-manager-mpm","text":"The toolkit is easy to install. The fastest and easiest way to acquire the toolkit is through mpm (Matlab Package Manager). mpm is a simple package manager for Matlab (inspired by pip ) and downloads packages from Matlab Central's File Exchange, GitHub repositories, or any other url pointing to a .zip file. Step 1: Downloading Sorotoki using MPM Install on mpm-package: You can directly clone the repository using the MPM command: mpm install sorotokicode -- all - paths This command will download SorotokiCode directly from the GitHub repository and create the SorotokiCode folder in the ./mpm-package folder. Installing in specified folder Install on desired location: Alternatively, the installation folder can be set to ~./Documents/MATLAB/ . This is done by running the following line: mpm install sorotokicode - d ~./ Documents / MATLAB / -- all - paths Error using mpm: This command is not supported when the mpm feature is not enabled. This error is due to the fact that MATLAB has its own function called mpm , which is in conflict with the mpm tools written by mobeets . To solve the issue, we can generate a file under ~./Documents/MATLAB called startup.m . This file is called during the startup of MATLAB, and will addpath of the mobeets-mpm folder. ./Documents/MATLAB/startup.m warning off % change USER to your username! USER = 'johndoe' ; if ispc addpath ([ 'C:\\Users\\' , USER , '\\AppData\\Roaming\\MathWorks\\,... ' \\ MATLAB Add - Ons \\ Collections / mpm / mobeets - mpm - c626429 ' ]); elseif isunix addpath ([ '/home/' , USER , '/MATLAB Add-Ons/Collections/mpm/mobeets-mpm-c626429' ]); end mpm init clc ; warning on Step 2: Running the installer After ensuring that all the necessary prerequisites are correctly installed, the next step involves configuring the toolkit with MATLAB's search paths. This process is relatively straightforward and can be accomplished by executing the following command: sorotoki cd % navigate to install folder sorotoki install -- approve % run installer (with auto approve) The toolkit will proceed with the installation by building search paths in Matlab. The toolkit will request the installation of the prerequisite toolboxes if they are not already installed. These include: Optimization Toolbox, Partial Differential Equation Toolbox, Image Processing Toolbox, and Matlab Coder. Especially the latter ensures that embedded Sorotoki functions can be converted to c or c++ equivalent code in the form of mex files, which greatly enhances computational performance. Finally, a verification routine is performed to check if the toolkit is installed correctly. Step 3: Building the toolkit Since Sorotoki uses the MATLAB Coder toolbox to speed-up computation, the toolkit still needs to be build. Here, MATLAB functions are converted to c++ executables that can be called from MATLAB as .mex files. To build these .mex files, we can simply call sorotoki build -- approve % build sorotoki executables Step 4: That's it folks And that's it, Sorotoki is now ready to use. The sorotoki installation command can also be used to run demo, check updates, see version number, and find the documentation file. You can do these by running the following commands: sorotoki demo % list demos sorotoki d % ... sorotoki version % version (and do i need to update?) sorotoki v % ... sorotoki doc % documentation link sorotoki i % ...","title":"Installation via Matlab Package Manager (MPM)"},{"location":"install/#manual-installation","text":"Alternatively, you can download the latest version of the toolkit below, and unpack the compressed folder at any desired working directory. We do not recommend this procedure, as MPM can help maintain the Sorotoki toolkit if future updates may appear. Sorotoki v.3.0.0.stable (code)","title":"Manual installation"},{"location":"install/#faq-and-installation-issues","text":"Darn', other problems during installation Please let me know by: Post an issue at: https://github.com/BJCaasenbrood/SorotokiCode/issues Get help directly at our Discord server","title":"FAQ and installation issues"},{"location":"release/","text":"Release Notes 2.07.22 - July 22 - 2022 Documentation update to the examples Modeling. Added minor description in auxilary functions in /src/ Fem.m Generated new mex files for the Local element computation. Now each matrix computation in during the fem simulation calls a .mex64 file. This significantly improves performance ~40% compare to .m files. During install, Sorotoki will ask to install the new mex files. Added (proper) friction effects to the contact simulations. A good example is fem_bouncingball.m which initally started spinning due to improper implementation of the friction forces during contact. The interaction friction can be modified under Material.Cfr (default = 1e-6 for most sample materials). Added example to show the friction effects is: ./scripts/fem/2D/dynamics/fem_crawler.m High interaction friction forces lead to instabilities, implement with caution. A fix will be issued later. Added initial conditions to the dynamic Fem simulations. Now Fem.Utmpcan be overwritten before calling fem.simulate. This can be extremely handy if we like to simulate from a quasi-static equilbrium, e.g., gravity deflection. One can first call fem.solve(), get the displacement through U0 = fem.Log.U(end,:) , then a new simulation: fem . reset (); fem . set ( 'Utmp' , U0 ); fem . simulate (); We can also ensure there is no ramping of the gravity force by setting the following fem.set('GravityRamp',false); Shapes.m Major update to the class. Now, Shapes.reconstruct() will produce better POD bases from the finite element simulations. As example: shp = Shapes ( fem , Modal , 'NNode' , 100 , 'L0' , 120 , 'FilterRadius' ,[ 15 , 15 ]); shp = shp . reference ([ 0 , 0 ],[ 119 , 0 ]); shp = shp . reconstruct (); This code will generate a basis from the data in Fem, and project its dynamics onto a curve spanned by the points: (0,0) -> (119,0). During the reconstruction, all system tensors are build accordingly. Shapes.show() is implemented and will show the strain basis. Model.m Fixed a minus error in the gravitional force compuation that lead to incorrect orientation of the gravity vector. 2.05.19 - May 19 - 2022 Fem.m : Addressed to solve Issue #7 : Fixed issue with Fem.Log. If a nonlinear residual increment takes less than 2 iterations, data was not properly stored. To solve this, any nonlinear time increment must take at least two steps, as to ensure a new displacement field is introduced to the stress-strain calculations. 2.05.17 - May 17 - 2022 Added MEX compiler for Model, Gmodel, and Fem classes. This significantly improves the computation times of the Sorotoki toolkit. When calling sorotoki.m , the installer asks to compile the mex files. Note we do not support the original Matlab functions anymore, simple because of computational speed. Hence, the Matlab Coder Toolkit is a prerequisite for Sorotoki. Updated verifySorotoki.m to include also Model. Shapes Updated the Fem -> Shapes converter that extracts the geometric modes from dynamic or quasi-static FEM data. This can be done using shp.Fem = Fem followed by shp.reconstruct , shp.rebuild . Then a dynamic model can be generated using mdl = Model(shp) . We call this new strain basis the Geometry-Informed Variable Strain basis as the geometry of the soft robot is preserved into the functional basis. Added Shapes.Material. Now hyper-elastic materials can be loaded into the stiffness and inertia tensor construction. The work is experimental since more research is required to properly include hyper-elastic materials into the Cosserat beam models. Model Added an auxiliary flow function to the Model class: dx = f(x,t) . This can be used for integrator actions, like PI controllers. or adaptive controllers where unknown parameters evolutions can be included. 2.01.28 - Jan 28 - 2022 Improved stability of Newmark solver. 2.24.01 - Jan 24 - 2022 Fixed broken installer. vernum.m file was missing on Repo. It has been replaced with soropatch.m which also includes the patch notes. @martijnschouten Missing DOI for citation, and long-term support/access. Signed Distance Functions : Added a new function Sdf.showcontour() . It will show the contour of 2D signed distance functions. Currently not implemented for 3D Sdfs. 2.13.01 - Jan 13 - 2022 Moved SOROTOKI from early alpha to alpha (prepping for official release). Shapes.m : Significant update to the class Shapes. Shapes now requests a Fem class , a Matlab function_handle of functionals, or a evaluated matrix of shape functions (); to construct the class. Then, it serves as an input for the class Model (e.g., dynamic modeling of soft robots), or as an Inverse Kinematic solver for beam models. Added a function Shapes.jointEstimate(Fem) . This will produce an optimal set of modal coefficient to reconstruct the beam model from FEM-driven data (accessed by Fem.Log). Current Shapes.jointEstimate() exploits the fact that the shapes are orthonormal w.r.t. their integral over the spatial domain [0,L]. If shapes do not satisfy this conditions, inaccurate estimates can occur. Added Y = gsog_poly(X) which ensure the columns of Y are mutually orthonormal derived from the matrix X. X must be full-rank. This function is simply the gramm-smith method for the innerproduct space int_C y_i y_j ds on the domain C := [0,L]. 1.12.06 - Dec 6 - 2021 Fem.m : Fixed some numerical issues with Fem.simulate() function. Stability is now further improved for larger timesteps. Fixed some numerical issues with Fem.Contact . A wider range of TimeSteps result now in stable solutions. Still the timestep size should be taken with care. Also fixed the issues of induced (unstable) oscillations due to fast impact. Contact is now based on the initial Modulus of the hyper-elastic material,i.e., Material.Emod() . Added time-base function_handle for the external pressures in dynamic finite-element simulations. They can added using: Fem.AddConstraint('Pressure',id, @(t) sin(t)) ; Dynamic simulations now record the potential and kinetic energies. Future implementation will have Load and Tendon-based dynamic forces The potential energy of the external load is still missing... 1.12.02 - Dec 2 - 2021 Finite Elements : Added Fem.simulate() function to the Nonlinear Finite Element. The function is a standard Newmark-Beta dynamic solver routine for NLFEM. Alternatively, fem.simulate() can be used as an alternative for fem.solve() by setting the Fem.Material.Zeta large (overdamped). Fixed the stability issue of Fem.Contact. Contact can now be added with Fem.AddConstraint('Contact',@(x) sdf(x), [x,y]) (x and y move the SDF). for best stability, use Fem.simulate() with a TimeStep < 1/75 . Open issues : Fem.simulate does not use dynamic external forces, rather the forces are scaled with a sigmoid function f_ext = f*sigmoid(t); This will be removed in the future with fext = @(t) f* .... - an explicit function of time that can be evaluated at time t. Possible implementations: Displace, Load, Pressure, Gravity. 1.10.06 - Oct 6 - 2021 Added patch.md file to keep track of any changes to SOROTOKI. Meshing : Fixed an issue where Mesh.showSDF was not producing plots. 1.10.01 - Oct 1 - 2021 Official beta release of SOROTOKI","title":"Release Notes"},{"location":"release/#release-notes","text":"","title":"Release Notes"},{"location":"release/#20722-july-22-2022","text":"Documentation update to the examples Modeling. Added minor description in auxilary functions in /src/ Fem.m Generated new mex files for the Local element computation. Now each matrix computation in during the fem simulation calls a .mex64 file. This significantly improves performance ~40% compare to .m files. During install, Sorotoki will ask to install the new mex files. Added (proper) friction effects to the contact simulations. A good example is fem_bouncingball.m which initally started spinning due to improper implementation of the friction forces during contact. The interaction friction can be modified under Material.Cfr (default = 1e-6 for most sample materials). Added example to show the friction effects is: ./scripts/fem/2D/dynamics/fem_crawler.m High interaction friction forces lead to instabilities, implement with caution. A fix will be issued later. Added initial conditions to the dynamic Fem simulations. Now Fem.Utmpcan be overwritten before calling fem.simulate. This can be extremely handy if we like to simulate from a quasi-static equilbrium, e.g., gravity deflection. One can first call fem.solve(), get the displacement through U0 = fem.Log.U(end,:) , then a new simulation: fem . reset (); fem . set ( 'Utmp' , U0 ); fem . simulate (); We can also ensure there is no ramping of the gravity force by setting the following fem.set('GravityRamp',false); Shapes.m Major update to the class. Now, Shapes.reconstruct() will produce better POD bases from the finite element simulations. As example: shp = Shapes ( fem , Modal , 'NNode' , 100 , 'L0' , 120 , 'FilterRadius' ,[ 15 , 15 ]); shp = shp . reference ([ 0 , 0 ],[ 119 , 0 ]); shp = shp . reconstruct (); This code will generate a basis from the data in Fem, and project its dynamics onto a curve spanned by the points: (0,0) -> (119,0). During the reconstruction, all system tensors are build accordingly. Shapes.show() is implemented and will show the strain basis. Model.m Fixed a minus error in the gravitional force compuation that lead to incorrect orientation of the gravity vector.","title":"2.07.22 - July 22 - 2022"},{"location":"release/#20519-may-19-2022","text":"Fem.m : Addressed to solve Issue #7 : Fixed issue with Fem.Log. If a nonlinear residual increment takes less than 2 iterations, data was not properly stored. To solve this, any nonlinear time increment must take at least two steps, as to ensure a new displacement field is introduced to the stress-strain calculations.","title":"2.05.19 - May 19 - 2022"},{"location":"release/#20517-may-17-2022","text":"Added MEX compiler for Model, Gmodel, and Fem classes. This significantly improves the computation times of the Sorotoki toolkit. When calling sorotoki.m , the installer asks to compile the mex files. Note we do not support the original Matlab functions anymore, simple because of computational speed. Hence, the Matlab Coder Toolkit is a prerequisite for Sorotoki. Updated verifySorotoki.m to include also Model. Shapes Updated the Fem -> Shapes converter that extracts the geometric modes from dynamic or quasi-static FEM data. This can be done using shp.Fem = Fem followed by shp.reconstruct , shp.rebuild . Then a dynamic model can be generated using mdl = Model(shp) . We call this new strain basis the Geometry-Informed Variable Strain basis as the geometry of the soft robot is preserved into the functional basis. Added Shapes.Material. Now hyper-elastic materials can be loaded into the stiffness and inertia tensor construction. The work is experimental since more research is required to properly include hyper-elastic materials into the Cosserat beam models. Model Added an auxiliary flow function to the Model class: dx = f(x,t) . This can be used for integrator actions, like PI controllers. or adaptive controllers where unknown parameters evolutions can be included.","title":"2.05.17 - May 17 - 2022"},{"location":"release/#20128-jan-28-2022","text":"Improved stability of Newmark solver.","title":"2.01.28 - Jan 28 - 2022"},{"location":"release/#22401-jan-24-2022","text":"Fixed broken installer. vernum.m file was missing on Repo. It has been replaced with soropatch.m which also includes the patch notes. @martijnschouten Missing DOI for citation, and long-term support/access. Signed Distance Functions : Added a new function Sdf.showcontour() . It will show the contour of 2D signed distance functions. Currently not implemented for 3D Sdfs.","title":"2.24.01 - Jan 24 - 2022"},{"location":"release/#21301-jan-13-2022","text":"Moved SOROTOKI from early alpha to alpha (prepping for official release). Shapes.m : Significant update to the class Shapes. Shapes now requests a Fem class , a Matlab function_handle of functionals, or a evaluated matrix of shape functions (); to construct the class. Then, it serves as an input for the class Model (e.g., dynamic modeling of soft robots), or as an Inverse Kinematic solver for beam models. Added a function Shapes.jointEstimate(Fem) . This will produce an optimal set of modal coefficient to reconstruct the beam model from FEM-driven data (accessed by Fem.Log). Current Shapes.jointEstimate() exploits the fact that the shapes are orthonormal w.r.t. their integral over the spatial domain [0,L]. If shapes do not satisfy this conditions, inaccurate estimates can occur. Added Y = gsog_poly(X) which ensure the columns of Y are mutually orthonormal derived from the matrix X. X must be full-rank. This function is simply the gramm-smith method for the innerproduct space int_C y_i y_j ds on the domain C := [0,L].","title":"2.13.01 - Jan 13 - 2022"},{"location":"release/#11206-dec-6-2021","text":"Fem.m : Fixed some numerical issues with Fem.simulate() function. Stability is now further improved for larger timesteps. Fixed some numerical issues with Fem.Contact . A wider range of TimeSteps result now in stable solutions. Still the timestep size should be taken with care. Also fixed the issues of induced (unstable) oscillations due to fast impact. Contact is now based on the initial Modulus of the hyper-elastic material,i.e., Material.Emod() . Added time-base function_handle for the external pressures in dynamic finite-element simulations. They can added using: Fem.AddConstraint('Pressure',id, @(t) sin(t)) ; Dynamic simulations now record the potential and kinetic energies. Future implementation will have Load and Tendon-based dynamic forces The potential energy of the external load is still missing...","title":"1.12.06 - Dec 6 - 2021"},{"location":"release/#11202-dec-2-2021","text":"Finite Elements : Added Fem.simulate() function to the Nonlinear Finite Element. The function is a standard Newmark-Beta dynamic solver routine for NLFEM. Alternatively, fem.simulate() can be used as an alternative for fem.solve() by setting the Fem.Material.Zeta large (overdamped). Fixed the stability issue of Fem.Contact. Contact can now be added with Fem.AddConstraint('Contact',@(x) sdf(x), [x,y]) (x and y move the SDF). for best stability, use Fem.simulate() with a TimeStep < 1/75 . Open issues : Fem.simulate does not use dynamic external forces, rather the forces are scaled with a sigmoid function f_ext = f*sigmoid(t); This will be removed in the future with fext = @(t) f* .... - an explicit function of time that can be evaluated at time t. Possible implementations: Displace, Load, Pressure, Gravity.","title":"1.12.02 - Dec 2 - 2021"},{"location":"release/#11006-oct-6-2021","text":"Added patch.md file to keep track of any changes to SOROTOKI. Meshing : Fixed an issue where Mesh.showSDF was not producing plots.","title":"1.10.06 - Oct 6 - 2021"},{"location":"release/#11001-oct-1-2021","text":"Official beta release of SOROTOKI","title":"1.10.01 - Oct 1 - 2021"},{"location":"code/mesh/","text":"::: test","title":"Mesh"},{"location":"control/controlboard/","text":"VEAB HAT (RPi) Image caption Schematics of the VEAB Raspberry Pi controller hat Printer-Circuit Board (PCB) Schematics (v2.11) Schematics of the VEAB Raspberry Pi controller hat Bill of material (BOM)","title":"VEAB HAT (RPi)"},{"location":"control/controlboard/#veab-hat-rpi","text":"Image caption Schematics of the VEAB Raspberry Pi controller hat","title":"VEAB HAT (RPi)"},{"location":"control/controlboard/#printer-circuit-board-pcb-schematics-v211","text":"Schematics of the VEAB Raspberry Pi controller hat","title":"Printer-Circuit Board (PCB) Schematics (v2.11)"},{"location":"control/controlboard/#bill-of-material-bom","text":"","title":"Bill of material (BOM)"},{"location":"control/i2chat/","text":"I2C Expander HAT (RPi) Schematics of the VEAB Raspberry Pi controller hat Printer-Circuit Board (PCB) Schematics (v2.11) Schematics of the VEAB Raspberry Pi controller hat Bill of material (BOM)","title":"I2C Expander HAT (RPi)"},{"location":"control/i2chat/#i2c-expander-hat-rpi","text":"Schematics of the VEAB Raspberry Pi controller hat","title":"I2C Expander HAT (RPi)"},{"location":"control/i2chat/#printer-circuit-board-pcb-schematics-v211","text":"Schematics of the VEAB Raspberry Pi controller hat","title":"Printer-Circuit Board (PCB) Schematics (v2.11)"},{"location":"control/i2chat/#bill-of-material-bom","text":"","title":"Bill of material (BOM)"},{"location":"control/orderveab/","text":"Place-and-order (JLCPCB) In the following documentation, we will show how to reproduce the VEAB controller hat (see below) step-by-step. This board can be produced by hand, but a better and easier alternative is to order it from a PCB manufacturer. Step 1: Choosing a PCB manufacturer There exist a couple of options for suitable PCB manufacturers. One we can recommend is JLCPCB located in Shenzhen, China. There website can be found at https://jlcpcb.com . The manufacturing files of the PCB board comply with this manufacturer. For the following steps, its easier to make an account with the PCB manufacturer. Step 2: Download and place gerber files Click on Order now (on the top right). Then add the gerber.zip (this contains all the macturing files for the VEAB control board) which can be downloaded from below: Download PCB gerber files (.zip) Step 3: Setting the PCB options Once the upload is complete, make sure you have \"similar\" options. * A minimum of ten boards must be selected to comply for SMT manufacturing. Alternatively, if you wish to solder the boards by hand, the order number does not matter. Also make sure you select Specify a location under Remove order number Step 4: Selecting SMT manufacturing Once you've selected the PCB setting, we can continue with SMT manufacturing. JLCPCB will not only produce the PCBs but also solder the components for us with this option enabled. Make sure you have the Top selected for the component placement, and also have Added by customers under Tooling holes . These tooling holes might depend on the PCB manufacturer (1.152mm for JLCPCB), and they assist with the component placement. The gerber files already have these holes on the board, thus no extra manufacturing steps are needed to be taken by JLCPCB. Press Confirm , and you'll be taken to a new page. Step 5: Adding the bill-of-materials (BOM) and footprint placement files In order for JLCPCB to assemble the board,they need to know which component are required and where they need to be placed. To do so, they require a bill-of-materials (BOM) and footprint placement file. These files can be found below: Download BOM file (.csv) Download Footprint position file (.csv) Step 6: Checking the JLCPCB's parts (in stock) You'll be greeted with an overview of all the components JLCPCB has in stock. Sometimes, it can happen that these components are not in stock. In most cases, the passive parts like resistors, capacitors, and inductors are in stock; but specialized components like the DACs, ADCs are not. If so, there are two options: Option 1: Find a replacement part that has an identical footprint, value, and property; and replace them in the BOM.csv. Option 2: Continue with the order, and JLCPCB will omit these parts from the assembly. This means you have to order the part elsewhere (i.e., Mouser/Farnell/Digikey) and hand-solder them. (only recommended for those with experience in SMD soldering). Options for the Digital-Analog converter (MCP4725 -- U3, U4): MCP4725A0T-E/CH -- C144198 (recommended) MCP4725A1T-E/CH -- C61423 MCP4726A0T-E/CH -- C191581 Options for the Analog-Digital converter (ADS1013 -- U5, U8): ADS1013IDGSR -- C524815 (recommended) ADS1014IDGST -- C132086 ADS1114IDGST -- C206016 ADS1015IDGSR -- C193969 Options for the buck-boost converter (SB6286 -- U2): SB6286 -- C157668 (recommended) SX1308 -- C78162 SY7208ABC -- C80514 AP2008TCER-ADJ -- C130341 Options for the OP-amp (LM358 -- U1, U6, U7, U9): - LM358DR2G -- C7950 (recommended) - LM358ADR -- C404320 If you wish to choose a different component, make the nessecary changes to BOM.csv under the column LCSC and add the corresponding Cxxxxxx number. In the next step, we will check the placement of these components is correct. Step 7: Checking component placement The next step is crucial -- the component placement. Although JLCPCB will (sometimes) double check any misplacements, it is better to check the placement yourself to be sure. JLCPCB will render the gerber files and the component placement files. Visualizations of bad placements (red boxes) and correct placements (green boxes) are show below. The red dots should match the white dots on the silkscreen. Here, we can see that the orientation of U2,U3, and U4 are off by 180 degrees. To fix the issue (if they may occur), we can modify the orientation in the Footprint_position.csv which can be done using a simple text editor, or using Excel. Possible orientations are: 0,90,180, and 270 ; which can be modified under Rotation in the .csv file. Step 8: Placing your order Once all the orientations are correct, press Save to Cart to finalize the order! Its that easy ;) PCB production is 2-3 days, SMT assembly is 3 days Hence, production time is roughly one week!","title":"Place-and-order (JLCPCB)"},{"location":"control/orderveab/#place-and-order-jlcpcb","text":"In the following documentation, we will show how to reproduce the VEAB controller hat (see below) step-by-step. This board can be produced by hand, but a better and easier alternative is to order it from a PCB manufacturer.","title":"Place-and-order (JLCPCB)"},{"location":"control/orderveab/#step-1-choosing-a-pcb-manufacturer","text":"There exist a couple of options for suitable PCB manufacturers. One we can recommend is JLCPCB located in Shenzhen, China. There website can be found at https://jlcpcb.com . The manufacturing files of the PCB board comply with this manufacturer. For the following steps, its easier to make an account with the PCB manufacturer.","title":"Step 1: Choosing a PCB manufacturer"},{"location":"control/orderveab/#step-2-download-and-place-gerber-files","text":"Click on Order now (on the top right). Then add the gerber.zip (this contains all the macturing files for the VEAB control board) which can be downloaded from below: Download PCB gerber files (.zip)","title":"Step 2: Download and place gerber files"},{"location":"control/orderveab/#step-3-setting-the-pcb-options","text":"Once the upload is complete, make sure you have \"similar\" options. * A minimum of ten boards must be selected to comply for SMT manufacturing. Alternatively, if you wish to solder the boards by hand, the order number does not matter. Also make sure you select Specify a location under Remove order number","title":"Step 3: Setting the PCB options"},{"location":"control/orderveab/#step-4-selecting-smt-manufacturing","text":"Once you've selected the PCB setting, we can continue with SMT manufacturing. JLCPCB will not only produce the PCBs but also solder the components for us with this option enabled. Make sure you have the Top selected for the component placement, and also have Added by customers under Tooling holes . These tooling holes might depend on the PCB manufacturer (1.152mm for JLCPCB), and they assist with the component placement. The gerber files already have these holes on the board, thus no extra manufacturing steps are needed to be taken by JLCPCB. Press Confirm , and you'll be taken to a new page.","title":"Step 4: Selecting SMT manufacturing"},{"location":"control/orderveab/#step-5-adding-the-bill-of-materials-bom-and-footprint-placement-files","text":"In order for JLCPCB to assemble the board,they need to know which component are required and where they need to be placed. To do so, they require a bill-of-materials (BOM) and footprint placement file. These files can be found below: Download BOM file (.csv) Download Footprint position file (.csv)","title":"Step 5: Adding the bill-of-materials (BOM) and footprint placement files"},{"location":"control/orderveab/#step-6-checking-the-jlcpcbs-parts-in-stock","text":"You'll be greeted with an overview of all the components JLCPCB has in stock. Sometimes, it can happen that these components are not in stock. In most cases, the passive parts like resistors, capacitors, and inductors are in stock; but specialized components like the DACs, ADCs are not. If so, there are two options: Option 1: Find a replacement part that has an identical footprint, value, and property; and replace them in the BOM.csv. Option 2: Continue with the order, and JLCPCB will omit these parts from the assembly. This means you have to order the part elsewhere (i.e., Mouser/Farnell/Digikey) and hand-solder them. (only recommended for those with experience in SMD soldering). Options for the Digital-Analog converter (MCP4725 -- U3, U4): MCP4725A0T-E/CH -- C144198 (recommended) MCP4725A1T-E/CH -- C61423 MCP4726A0T-E/CH -- C191581 Options for the Analog-Digital converter (ADS1013 -- U5, U8): ADS1013IDGSR -- C524815 (recommended) ADS1014IDGST -- C132086 ADS1114IDGST -- C206016 ADS1015IDGSR -- C193969 Options for the buck-boost converter (SB6286 -- U2): SB6286 -- C157668 (recommended) SX1308 -- C78162 SY7208ABC -- C80514 AP2008TCER-ADJ -- C130341 Options for the OP-amp (LM358 -- U1, U6, U7, U9): - LM358DR2G -- C7950 (recommended) - LM358ADR -- C404320 If you wish to choose a different component, make the nessecary changes to BOM.csv under the column LCSC and add the corresponding Cxxxxxx number. In the next step, we will check the placement of these components is correct.","title":"Step 6: Checking the JLCPCB's parts (in stock)"},{"location":"control/orderveab/#step-7-checking-component-placement","text":"The next step is crucial -- the component placement. Although JLCPCB will (sometimes) double check any misplacements, it is better to check the placement yourself to be sure. JLCPCB will render the gerber files and the component placement files. Visualizations of bad placements (red boxes) and correct placements (green boxes) are show below. The red dots should match the white dots on the silkscreen. Here, we can see that the orientation of U2,U3, and U4 are off by 180 degrees. To fix the issue (if they may occur), we can modify the orientation in the Footprint_position.csv which can be done using a simple text editor, or using Excel. Possible orientations are: 0,90,180, and 270 ; which can be modified under Rotation in the .csv file.","title":"Step 7: Checking component placement"},{"location":"control/orderveab/#step-8-placing-your-order","text":"Once all the orientations are correct, press Save to Cart to finalize the order! Its that easy ;) PCB production is 2-3 days, SMT assembly is 3 days Hence, production time is roughly one week!","title":"Step 8: Placing your order"},{"location":"fem/fem/","text":"Finite Elements ( Fem.m ) The Sorotoki toolkit offers a nonlinear finite element solver for both quasi-static and fully dynamic simulations. FEM-based tools are crucial when describing large deformations in soft robots, which also accounts for hyperelastic materials and geometric nonlinearities. The FEM package is provided in a class called Fem.m and can be instantiated using fem = Fem(Mesh) . This class serves two main purposes: ( \\(i\\) ) to solve static or dynamic continuum problems with high accuracy, and ( \\(ii\\) ) to solve gradient-based optimization problems, also known as inverse design problems. It is important to note that, unlike SOFA , the focus of Sorotoki is on high-detail simulations rather than real-time implementation for control. The presented FEM simulation models are not intended for real-time applications, but rather for system identification and analysis. High-detail finite element model The nonlinear dynamics of the finite element model in Sorotoki , similar to SOFA and Gibbon , can be described by the general Newton-Euler equation of motion: \\[\\mathbf{M} \\ddot{\\mathbf{x}} + \\mathbf{f}_{\\textrm{mat}}(\\mathbf{x},\\dot{\\mathbf{x}}) + \\mathbf{f}_{\\textrm{g}} = \\mathbf{f}_{\\textrm{u}}(\\mathbf{x},\\mathbf{u},t) + \\mathbf{f}_{\\Omega_{\\textrm{env}}}(\\mathbf{x},\\dot{\\mathbf{x}},t), \\] where \\(\\mathbf{x}\\) , \\(\\dot{\\mathbf{x}}\\) , and \\(\\ddot{\\mathbf{x}}\\) are the global nodal displacement, velocities and accelerations of the mesh tesselation, respectively; \\(\\mathbf{M}\\) the constant generalized mass matrix, \\(\\mathbf{f}_\\textrm{mat}\\) the internal soft material forces, \\(\\mathbf{f}_\\textrm{g}\\) the constant gravitational forces, \\(\\mathbf{f}_u\\) a user-defined input, and \\(\\mathbf{f}_{\\Omega_{\\textrm{env}}}\\) the normal reaction forces and tangent friction forces imposed by the dynamic contact with a (possibly time-dependent) environment \\(\\Omega_{\\textrm{env}}\\) . The environment \\(\\Omega_{\\textrm{env}}\\) can be described using the SDF functionality (see Section \\ref{sec:C5:sdf}) using the syntax fem.addContact(sdf) . A broad collection of generalized external inputs can be added using: fem.addLoad , fem.addDisplace , fem.addGravity , and fem.addTendon . Alternatively, time-varying pressure inputs can be added using the command fem.addPressure . Without loss of generality, the material force can be decomposed into a position-dependent and velocity-dependent part: \\(\\mathbf{f}_{\\textrm{mat}}(\\mathbf{x},\\dot{\\mathbf{x}}) = \\mathbf{f}_{\\textrm{e}}(\\mathbf{x}) + \\mathbf{f}_{\\textrm{d}}(\\dot{\\mathbf{x}})\\) , i.e., an elastic and dissipation contribution, respectively. We assume that the dissipation is given by \\(\\mathbf{f}_{\\textrm{d}} = \\zeta \\mathbf{M} \\dot{\\mathbf{x}}\\) with damping coefficient \\(\\zeta > 0\\) . Materials can be assigned using fem.addMaterial . It shall be clear that the conservative elastic material forces \\(\\mathbf{f}_{\\textrm{e}}\\) require more involved computation. Since this computation is not straightforward, we briefly explain the derivation of the nonlinear hyper-elastic material forces, which follows standard nonlinear finite element procedures 1 2 3 . Nam Ho Kim. Introduction Analysis Finite Element to Nonlinear . Springer, 2018. ISBN 9781441917454. \u21a9 Gerhard A. Holzapfel. Nonlinear Solid Mechanics: A Continuum Approach for Engineering Science . Volume 37. Kluwer Academic Publishers, Heidelberg, Germany, July 2002. doi:10.1023/A:1020843529530 . \u21a9 Breannan Smith, Fernando De Goes, and Theodore Kim. Stable neo-hookean flesh simulation. ACM Trans. Graph. , mar 2018. URL: https://doi.org/10.1145/3180491 , doi:10.1145/3180491 . \u21a9","title":"Finite Elements (`Fem.m`)"},{"location":"fem/fem/#finite-elements-femm","text":"The Sorotoki toolkit offers a nonlinear finite element solver for both quasi-static and fully dynamic simulations. FEM-based tools are crucial when describing large deformations in soft robots, which also accounts for hyperelastic materials and geometric nonlinearities. The FEM package is provided in a class called Fem.m and can be instantiated using fem = Fem(Mesh) . This class serves two main purposes: ( \\(i\\) ) to solve static or dynamic continuum problems with high accuracy, and ( \\(ii\\) ) to solve gradient-based optimization problems, also known as inverse design problems. It is important to note that, unlike SOFA , the focus of Sorotoki is on high-detail simulations rather than real-time implementation for control. The presented FEM simulation models are not intended for real-time applications, but rather for system identification and analysis.","title":"Finite Elements (Fem.m)"},{"location":"fem/fem/#high-detail-finite-element-model","text":"The nonlinear dynamics of the finite element model in Sorotoki , similar to SOFA and Gibbon , can be described by the general Newton-Euler equation of motion: \\[\\mathbf{M} \\ddot{\\mathbf{x}} + \\mathbf{f}_{\\textrm{mat}}(\\mathbf{x},\\dot{\\mathbf{x}}) + \\mathbf{f}_{\\textrm{g}} = \\mathbf{f}_{\\textrm{u}}(\\mathbf{x},\\mathbf{u},t) + \\mathbf{f}_{\\Omega_{\\textrm{env}}}(\\mathbf{x},\\dot{\\mathbf{x}},t), \\] where \\(\\mathbf{x}\\) , \\(\\dot{\\mathbf{x}}\\) , and \\(\\ddot{\\mathbf{x}}\\) are the global nodal displacement, velocities and accelerations of the mesh tesselation, respectively; \\(\\mathbf{M}\\) the constant generalized mass matrix, \\(\\mathbf{f}_\\textrm{mat}\\) the internal soft material forces, \\(\\mathbf{f}_\\textrm{g}\\) the constant gravitational forces, \\(\\mathbf{f}_u\\) a user-defined input, and \\(\\mathbf{f}_{\\Omega_{\\textrm{env}}}\\) the normal reaction forces and tangent friction forces imposed by the dynamic contact with a (possibly time-dependent) environment \\(\\Omega_{\\textrm{env}}\\) . The environment \\(\\Omega_{\\textrm{env}}\\) can be described using the SDF functionality (see Section \\ref{sec:C5:sdf}) using the syntax fem.addContact(sdf) . A broad collection of generalized external inputs can be added using: fem.addLoad , fem.addDisplace , fem.addGravity , and fem.addTendon . Alternatively, time-varying pressure inputs can be added using the command fem.addPressure . Without loss of generality, the material force can be decomposed into a position-dependent and velocity-dependent part: \\(\\mathbf{f}_{\\textrm{mat}}(\\mathbf{x},\\dot{\\mathbf{x}}) = \\mathbf{f}_{\\textrm{e}}(\\mathbf{x}) + \\mathbf{f}_{\\textrm{d}}(\\dot{\\mathbf{x}})\\) , i.e., an elastic and dissipation contribution, respectively. We assume that the dissipation is given by \\(\\mathbf{f}_{\\textrm{d}} = \\zeta \\mathbf{M} \\dot{\\mathbf{x}}\\) with damping coefficient \\(\\zeta > 0\\) . Materials can be assigned using fem.addMaterial . It shall be clear that the conservative elastic material forces \\(\\mathbf{f}_{\\textrm{e}}\\) require more involved computation. Since this computation is not straightforward, we briefly explain the derivation of the nonlinear hyper-elastic material forces, which follows standard nonlinear finite element procedures 1 2 3 . Nam Ho Kim. Introduction Analysis Finite Element to Nonlinear . Springer, 2018. ISBN 9781441917454. \u21a9 Gerhard A. Holzapfel. Nonlinear Solid Mechanics: A Continuum Approach for Engineering Science . Volume 37. Kluwer Academic Publishers, Heidelberg, Germany, July 2002. doi:10.1023/A:1020843529530 . \u21a9 Breannan Smith, Fernando De Goes, and Theodore Kim. Stable neo-hookean flesh simulation. ACM Trans. Graph. , mar 2018. URL: https://doi.org/10.1145/3180491 , doi:10.1145/3180491 . \u21a9","title":"High-detail finite element model"},{"location":"fem/hyperelast/","text":"Hyper-elastic materials An important aspect of soft robotics in general is to accurately describe large nonlinear deformations of inertial continuum bodies in motion. Yet, due to these large deformations, many classical Hookean elasticity models may not be accurate for elastomer materials. To address this, Sorotoki provides a library of hyper-elastic constitutive material models: Neo-Hookean (NH), Mooney-Rivlin (MR), and Yeoh model (YH). The strain energy densities for these models are derived based on the strain invariants \\(I_1\\) , \\(I_2\\) , and \\(I_3\\) provided in Table \\ref{tab:C5:strain_measures} and are shown in Table The material models presented in Table \\ref{tab:C5:elasticitymodels} are implemented in \\textit{Sorotoki} under the class \\class{Material}, but have specific constructors tailored towards each material, \\texttt{NeoHookeanMaterial}, \\texttt{MooneyMaterial}, and \\texttt{YeohMaterial}. Regarding their parameters, the work of Marechal et al. \\cite{Marechal2021Jun} provides an open-source database that includes a broad collection of soft materials commonly used in soft robotics, gathered through uniaxial material tests. Based on their dataset and relevant other literature \\cite{Xavier2022Jun,Smith2018,Kim2018,Goury2018}, \\textit{Sorotoki} offers some preset material models of soft materials commonly used in soft robotics, such as the Ecoflex30/50 series, Dragonskin10/30 series, NinjaFlex, and Formlabs Elastic50A/80A material. These material classes also include the physical data for density, viscosity, and tangential contact friction. Following \\eqref{eq:C5:fem_hyper}, the first Piola-Kirchhoff (PK1) stress tensor is evaluated analytically using the function call \\code{P = Material.PiollaStress(F)}.","title":"Hyper-elastic materials"},{"location":"fem/hyperelast/#hyper-elastic-materials","text":"An important aspect of soft robotics in general is to accurately describe large nonlinear deformations of inertial continuum bodies in motion. Yet, due to these large deformations, many classical Hookean elasticity models may not be accurate for elastomer materials. To address this, Sorotoki provides a library of hyper-elastic constitutive material models: Neo-Hookean (NH), Mooney-Rivlin (MR), and Yeoh model (YH). The strain energy densities for these models are derived based on the strain invariants \\(I_1\\) , \\(I_2\\) , and \\(I_3\\) provided in Table \\ref{tab:C5:strain_measures} and are shown in Table The material models presented in Table \\ref{tab:C5:elasticitymodels} are implemented in \\textit{Sorotoki} under the class \\class{Material}, but have specific constructors tailored towards each material, \\texttt{NeoHookeanMaterial}, \\texttt{MooneyMaterial}, and \\texttt{YeohMaterial}. Regarding their parameters, the work of Marechal et al. \\cite{Marechal2021Jun} provides an open-source database that includes a broad collection of soft materials commonly used in soft robotics, gathered through uniaxial material tests. Based on their dataset and relevant other literature \\cite{Xavier2022Jun,Smith2018,Kim2018,Goury2018}, \\textit{Sorotoki} offers some preset material models of soft materials commonly used in soft robotics, such as the Ecoflex30/50 series, Dragonskin10/30 series, NinjaFlex, and Formlabs Elastic50A/80A material. These material classes also include the physical data for density, viscosity, and tangential contact friction. Following \\eqref{eq:C5:fem_hyper}, the first Piola-Kirchhoff (PK1) stress tensor is evaluated analytically using the function call \\code{P = Material.PiollaStress(F)}.","title":"Hyper-elastic materials"},{"location":"fem/inverse/","text":"Computational design Besides modeling, the field of computational inverse design can also benefit from the use of FEM models. Building up the \\class{Fem} class, the objective is to find a topological structure of a continuum system based on a desired deformations or compliance. One widely adopted method is the Solid Isotropic Material with Penalization (SIMP) approach, which is a commonly used material interpolation technique in topology optimization \\cite{Bendsoe2003}. In the SIMP method, each finite element \\(e \\in \\{1,2,...,n_e \\}\\) is assigned a continuous density variable \\(\\rho_e \\in (0,1]\\) , which serves as an indicator of the material distribution within the mesh. If \\(\\rho_e = 1\\) , the element is considered solid, while if \\(\\rho_e = 0\\) , the element is considered void. This assignment of density variables enables the modification of the strain energy density in \\(\\Psi\\) : \\(\\renewcommand{\\elastic}{_\\textrm{e}}\\) \\(\\renewcommand{\\grav}{_\\textrm{g}}\\) \\(\\renewcommand{\\p}{\\partial}\\) \\(\\renewcommand{\\R}{\\mathbb{R}}\\) \\(\\renewcommand{\\vec}[1]{\\mathbf{#1}}\\) \\(\\renewcommand{\\mat}[1]{\\mathbf{#1}}\\) \\(\\renewcommand{\\FB}{\\mathbf{F}}\\) \\(\\renewcommand{\\LB}{\\mathbf{L}}\\) \\(\\renewcommand{\\fB}{\\mathbf{f}}\\) \\(\\renewcommand{\\Hm}{\\mathcal{H}}\\) \\(\\renewcommand{\\xB}{\\mathbf{x}}\\) \\(\\renewcommand{\\AB}{\\mathbf{A}}\\) \\(\\renewcommand{\\x}{\\mathbf{x}}\\) \\(\\renewcommand{\\dxB}{\\dot{\\mathbf{x}}}\\) \\(\\renewcommand{\\dt}{\\delta t}\\) \\(\\renewcommand{\\ddxB}{\\ddot{\\mathbf{x}}}\\) \\[ \\tilde{\\Psi}_{e} = \\left[ \\varepsilon + (1-\\varepsilon){\\rho_e}^p \\right] \\Psi, \\] where \\(0 < \\varepsilon \\ll 1\\) a lower bound on the densities, and \\(p > 1\\) a penalty factor for penalizing intermediate densities during the optimization process. By collecting the density values \\(\\vec{\\rho} = \\textrm{col}\\{\\rho_1,\\rho_2,...,\\rho_{N_e}\\}\\) , the inverse design problem can be formulated in terms of two unknowns: the displacement field \\(\\xB\\) and the density field \\(\\vec{\\rho}\\) . Consequently, the computational design problem for general soft material structures can be expressed as a nonlinear topology optimization problem of the following form: \\[ \\begin{align} \\underset{\\vec{\\rho}}{\\textrm{minimize}}\\quad & {\\Phi = -\\beta_1\\, \\LB^\\top\\!\\x \\;+\\; \\beta_2 \\fB\\elastic^\\top \\! \\fB_{\\textrm{u}} } \\\\ \\textrm{subject to} \\quad& \\tilde{\\vec{r}}(\\xB,\\vec{\\rho})=0, \\\\[0.25em] & \\vec{v}^\\top \\vec{\\rho}\\le v^\\star, \\\\[0.25em] & \\vec{\\rho}\\in \\mathcal{P}, \\label{eq:C5:topo_optimization} \\end{align} \\] where \\(\\LB\\) a sparse unit-vector composed of nonzero entries for the degrees-of-freedom corresponding to the desired morphology of the soft robot, \\(\\vec{v}\\) the element volumes, \\(v*\\) the desired volume infill, \\(\\mathcal{P} = \\left\\{ \\vec{\\rho} \\in \\R^{n_e} ~|~ 0 < \\rho_i \\le 1\\right\\}\\) admissible set for the design variables, and \\(\\beta_1\\) and \\(\\beta_2\\) are positive scalars that can be adjusted to vary the optimization problem, with \\(\\beta_1 \\ll \\beta_2\\) resulting in compliance minimization and \\(\\beta_1 \\gg \\beta_2\\) leading to a compliant mechanism. To solve the optimization problem in \\eqref{eq:C5:topo_optimization}, we utilize the Method of Mixed Asymptotes (MMA) proposed by Svanberg 1 2 . Earlier work on this computational design approach was presented in Caasenbrood et al. 3 , and the chapter is referred to this work for the analytic gradients required for the MMA solver. The optimization routine in the Sorotoki framework is incorporated into the Fem class and can be invoked by utilizing the command fem.optimize('type') , where 'type' represents the optimization problem at hand. For minimizing compliance, the cost function is self-adjoint \\cite{Bendsoe2003}, hence objective function and constraints are linear operators. However, when dealing with compliant mechanisms, it is necessary to specify the selection vector \\(\\LB\\) , which can be defined using the fem.addOutput(id) command. The value of id represents the nodal indices of interest, which can be identified using the fem.Mesh.findNode functionality. Example: optimization of linear elastic beam 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 msh = Mesh ( sRectangle ( 4 , 10 ), 'Quads' ,[ 40 , 100 ]); msh = msh . generate (); fem = Fem ( msh , 'SpatialFilterRadius' , 0.3 ); fem = fem . addMaterial ( NeoHookean ); fem = fem . addSupport ( 'nw' ,[ 1 , 1 ]); fem = fem . addSupport ( 'sw' ,[ 1 , 1 ]); fem = fem . addLoad ( 'leftmid' ,[ 1 , 0 ]); fem . options . isNonlinear = false ; fem . options . LineStyle = 'none' ; fem . options . Display = @ plt ; fem = fem . optimize ; function plt ( Fem ) cla ; showInfillFem ( Fem ); end Krister Svanberg. The method of moving asymptotes\\ifmmode \u2014\\else \u2014\\fi a new method for structural optimization. International Journal for Numerical Methods in Engineering , 24(2):359\u2013373, 1987. doi:10.1002/nme.1620240207 . \u21a9 Krister Svanberg. Mma and gcmma-two methods for nonlinear optimization. vol , 1:1\u201315, 2007. \u21a9 Brandon Caasenbrood, Alexander Pogromsky, and Henk Nijmeijer. Dynamic modeling of hyper-elastic soft robots using spatial curves. IFAC Proceedings Volumes (IFAC-PapersOnline) , 2020. \u21a9","title":"Computational design"},{"location":"fem/inverse/#computational-design","text":"Besides modeling, the field of computational inverse design can also benefit from the use of FEM models. Building up the \\class{Fem} class, the objective is to find a topological structure of a continuum system based on a desired deformations or compliance. One widely adopted method is the Solid Isotropic Material with Penalization (SIMP) approach, which is a commonly used material interpolation technique in topology optimization \\cite{Bendsoe2003}. In the SIMP method, each finite element \\(e \\in \\{1,2,...,n_e \\}\\) is assigned a continuous density variable \\(\\rho_e \\in (0,1]\\) , which serves as an indicator of the material distribution within the mesh. If \\(\\rho_e = 1\\) , the element is considered solid, while if \\(\\rho_e = 0\\) , the element is considered void. This assignment of density variables enables the modification of the strain energy density in \\(\\Psi\\) : \\(\\renewcommand{\\elastic}{_\\textrm{e}}\\) \\(\\renewcommand{\\grav}{_\\textrm{g}}\\) \\(\\renewcommand{\\p}{\\partial}\\) \\(\\renewcommand{\\R}{\\mathbb{R}}\\) \\(\\renewcommand{\\vec}[1]{\\mathbf{#1}}\\) \\(\\renewcommand{\\mat}[1]{\\mathbf{#1}}\\) \\(\\renewcommand{\\FB}{\\mathbf{F}}\\) \\(\\renewcommand{\\LB}{\\mathbf{L}}\\) \\(\\renewcommand{\\fB}{\\mathbf{f}}\\) \\(\\renewcommand{\\Hm}{\\mathcal{H}}\\) \\(\\renewcommand{\\xB}{\\mathbf{x}}\\) \\(\\renewcommand{\\AB}{\\mathbf{A}}\\) \\(\\renewcommand{\\x}{\\mathbf{x}}\\) \\(\\renewcommand{\\dxB}{\\dot{\\mathbf{x}}}\\) \\(\\renewcommand{\\dt}{\\delta t}\\) \\(\\renewcommand{\\ddxB}{\\ddot{\\mathbf{x}}}\\) \\[ \\tilde{\\Psi}_{e} = \\left[ \\varepsilon + (1-\\varepsilon){\\rho_e}^p \\right] \\Psi, \\] where \\(0 < \\varepsilon \\ll 1\\) a lower bound on the densities, and \\(p > 1\\) a penalty factor for penalizing intermediate densities during the optimization process. By collecting the density values \\(\\vec{\\rho} = \\textrm{col}\\{\\rho_1,\\rho_2,...,\\rho_{N_e}\\}\\) , the inverse design problem can be formulated in terms of two unknowns: the displacement field \\(\\xB\\) and the density field \\(\\vec{\\rho}\\) . Consequently, the computational design problem for general soft material structures can be expressed as a nonlinear topology optimization problem of the following form: \\[ \\begin{align} \\underset{\\vec{\\rho}}{\\textrm{minimize}}\\quad & {\\Phi = -\\beta_1\\, \\LB^\\top\\!\\x \\;+\\; \\beta_2 \\fB\\elastic^\\top \\! \\fB_{\\textrm{u}} } \\\\ \\textrm{subject to} \\quad& \\tilde{\\vec{r}}(\\xB,\\vec{\\rho})=0, \\\\[0.25em] & \\vec{v}^\\top \\vec{\\rho}\\le v^\\star, \\\\[0.25em] & \\vec{\\rho}\\in \\mathcal{P}, \\label{eq:C5:topo_optimization} \\end{align} \\] where \\(\\LB\\) a sparse unit-vector composed of nonzero entries for the degrees-of-freedom corresponding to the desired morphology of the soft robot, \\(\\vec{v}\\) the element volumes, \\(v*\\) the desired volume infill, \\(\\mathcal{P} = \\left\\{ \\vec{\\rho} \\in \\R^{n_e} ~|~ 0 < \\rho_i \\le 1\\right\\}\\) admissible set for the design variables, and \\(\\beta_1\\) and \\(\\beta_2\\) are positive scalars that can be adjusted to vary the optimization problem, with \\(\\beta_1 \\ll \\beta_2\\) resulting in compliance minimization and \\(\\beta_1 \\gg \\beta_2\\) leading to a compliant mechanism. To solve the optimization problem in \\eqref{eq:C5:topo_optimization}, we utilize the Method of Mixed Asymptotes (MMA) proposed by Svanberg 1 2 . Earlier work on this computational design approach was presented in Caasenbrood et al. 3 , and the chapter is referred to this work for the analytic gradients required for the MMA solver. The optimization routine in the Sorotoki framework is incorporated into the Fem class and can be invoked by utilizing the command fem.optimize('type') , where 'type' represents the optimization problem at hand. For minimizing compliance, the cost function is self-adjoint \\cite{Bendsoe2003}, hence objective function and constraints are linear operators. However, when dealing with compliant mechanisms, it is necessary to specify the selection vector \\(\\LB\\) , which can be defined using the fem.addOutput(id) command. The value of id represents the nodal indices of interest, which can be identified using the fem.Mesh.findNode functionality. Example: optimization of linear elastic beam 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 msh = Mesh ( sRectangle ( 4 , 10 ), 'Quads' ,[ 40 , 100 ]); msh = msh . generate (); fem = Fem ( msh , 'SpatialFilterRadius' , 0.3 ); fem = fem . addMaterial ( NeoHookean ); fem = fem . addSupport ( 'nw' ,[ 1 , 1 ]); fem = fem . addSupport ( 'sw' ,[ 1 , 1 ]); fem = fem . addLoad ( 'leftmid' ,[ 1 , 0 ]); fem . options . isNonlinear = false ; fem . options . LineStyle = 'none' ; fem . options . Display = @ plt ; fem = fem . optimize ; function plt ( Fem ) cla ; showInfillFem ( Fem ); end Krister Svanberg. The method of moving asymptotes\\ifmmode \u2014\\else \u2014\\fi a new method for structural optimization. International Journal for Numerical Methods in Engineering , 24(2):359\u2013373, 1987. doi:10.1002/nme.1620240207 . \u21a9 Krister Svanberg. Mma and gcmma-two methods for nonlinear optimization. vol , 1:1\u201315, 2007. \u21a9 Brandon Caasenbrood, Alexander Pogromsky, and Henk Nijmeijer. Dynamic modeling of hyper-elastic soft robots using spatial curves. IFAC Proceedings Volumes (IFAC-PapersOnline) , 2020. \u21a9","title":"Computational design"},{"location":"fem/solid/","text":"Continuum deformation Note that the conservative elastic material forces \\(f_{\\textrm{e}}\\) in general require some rather involved computation. Since this computation is not straightforward, we briefly explain the derivation of the nonlinear hyper-elastic material forces, which follows standard nonlinear finite element procedures 1 2 3 . \\(\\renewcommand{\\p}{\\partial}\\) \\(\\renewcommand{\\R}{\\mathbb{R}}\\) \\(\\renewcommand{\\vec}[1]{\\mathbb{#1}}\\) \\(\\renewcommand{\\FB}{\\mathbf{F}}\\) \\(\\renewcommand{\\fB}{\\mathbf{f}}\\) \\(\\renewcommand{\\x}{\\mathbf{x}}\\) Intermezzo: deformation gradient A fundamental measure of deformation in continuum mechanics is the deformation gradient, denoted by \\(\\mathbf{F}\\) . The deformation gradient characterizes the local deformation for a neighborhood of the continuum body \\(\\Omega\\) . Since a subvolume of the continuum body cannot be reduced to a point, it follows that \\(\\det{\\mathbf{F}} = J > 0\\) and \\(\\mathbf{F}^{-1}\\) exists. The term \\(J\\) is called the relative volume change and it is equal to 1 for isochoric deformations, such as rigid body deformations. Given these properties, the deformation gradient can then be factorized into \\(\\mathbf{F} = \\mathbf{Q} \\mathbf{V}\\) , where \\(\\mathbf{V} \\succ 0\\) is the right-handed stretch tensor and \\(\\mathbf{Q} \\in \\mathrm{SO}(3)\\) is a rotation matrix belonging to the special orthogonal group 1 2 . For convenience, we summarize the derived quantities of \\(\\mathbf{F}\\) in the table below that will be used throughout this section. Relative volume change Polar decomposition Right Cauchy-Green tensor \\(J = \\det(\\mathbf{F})\\) \\(\\mathbf{F} = \\mathbf{Q} \\mathbf{V}\\) \\(\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F}\\) First strain invariant Second strain invariant Third strain invariant \\(I_1 = \\textrm{tr}(\\mathbf{C})\\) \\(I_2 = \\frac{1}{2} \\left[\\textrm{tr}(\\mathbf{C})^2 - \\textrm{tr}(\\mathbf{C}^2)\\right]\\) \\(I_3 = \\det(\\mathbf{C})\\) Intermezzo: Derivation of hyperelastic forces Let \\(\\Omega_i\\) denote the subspace spanned by the \\(i\\) -th element of the finite element mesh, and let \\(\\x_i\\) denote its nodal displacement vector. The elasticity of the constitutive soft material can be described by a strain-energy density function \\(\\Psi: \\FB \\to \\R_{\\ge 0}\\) . A comprehensive discussion on common constitutive models for \\(\\Psi\\) will be provided later in the subsequent paragraph. The elastic potential energy of the continuum body is given by \\(\\mathcal{U}_e = \\int_\\Omega \\Psi(\\cdot) \\; dV\\) , and the conservative hyper-elastic force contribution can be computed as \\(\\fB_e := \\nabla_{\\x}\\,\\mathcal{U}_e\\) . This contribution can be approximated using piecewise finite element interpolation and integrated using the Gauss quadrature rule 1 as follows: \\[ \\begin{align} \\fB_\\textrm{e}(\\x) & = \\sum_{i=1}^{N_e} \\frac{d}{d\\x_i} \\left\\{\\int_{\\Omega_i} \\Psi(\\FB(\\x_i,s)) \\; ds\\right\\}, \\\\ & \\approx \\sum_{i=1}^{N_e} \\sum_{j=1}^{N_w} w_j \\, \\underbrace{\\frac{\\p \\Psi}{\\p \\FB}(\\FB(\\x_i,s_j)) }_{\\textrm{PK1}} \\frac{\\p \\FB}{\\p \\x_i}(\\x_i,s_j) \\end{align} \\] where the Gauss weights are denoted by \\(w_j > 0\\) , and the number of finite elements and Gauss samples are represented by \\(N_e\\) and \\(N_w\\) , respectively. The term \\({\\partial \\Psi}/{\\partial \\FB}\\) is also referred to as the first Piolla-Kirchhoff (PK1) stress tensor, which can be represented in closed-form for many constitutive models. The term \\({\\partial \\FB}/{\\partial \\x_e}\\) denotes the deformation Jacobian, which can also be given in closed-form but depends on the choice of element type. In addition to the first Piolla stress tensor, we also introduce the Cauchy stress tensor (i.e., true stress) \\(\\vec{\\sigma} := J^{-1} \\frac{\\partial \\Psi}{\\partial \\FB} \\FB^\\top\\) , which is a symmetric second-order tensor whose components represent the true stress. It should be noted that these tensor calculations are highly nonlinear, making their computation the most time-consuming aspect of the finite element assembly. To enhance computational efficiency, the toolkit employs \\texttt{.mex} executable code, generated during installation (\\texttt{Matlab Coder} is required). Nam Ho Kim. Introduction Analysis Finite Element to Nonlinear . Springer, 2018. ISBN 9781441917454. \u21a9 \u21a9 \u21a9 Gerhard A. Holzapfel. Nonlinear Solid Mechanics: A Continuum Approach for Engineering Science . Volume 37. Kluwer Academic Publishers, Heidelberg, Germany, July 2002. doi:10.1023/A:1020843529530 . \u21a9 \u21a9 Breannan Smith, Fernando De Goes, and Theodore Kim. Stable neo-hookean flesh simulation. ACM Trans. Graph. , mar 2018. URL: https://doi.org/10.1145/3180491 , doi:10.1145/3180491 . \u21a9","title":"Continuum deformation"},{"location":"fem/solid/#continuum-deformation","text":"Note that the conservative elastic material forces \\(f_{\\textrm{e}}\\) in general require some rather involved computation. Since this computation is not straightforward, we briefly explain the derivation of the nonlinear hyper-elastic material forces, which follows standard nonlinear finite element procedures 1 2 3 . \\(\\renewcommand{\\p}{\\partial}\\) \\(\\renewcommand{\\R}{\\mathbb{R}}\\) \\(\\renewcommand{\\vec}[1]{\\mathbb{#1}}\\) \\(\\renewcommand{\\FB}{\\mathbf{F}}\\) \\(\\renewcommand{\\fB}{\\mathbf{f}}\\) \\(\\renewcommand{\\x}{\\mathbf{x}}\\)","title":"Continuum deformation"},{"location":"fem/solid/#intermezzo-deformation-gradient","text":"A fundamental measure of deformation in continuum mechanics is the deformation gradient, denoted by \\(\\mathbf{F}\\) . The deformation gradient characterizes the local deformation for a neighborhood of the continuum body \\(\\Omega\\) . Since a subvolume of the continuum body cannot be reduced to a point, it follows that \\(\\det{\\mathbf{F}} = J > 0\\) and \\(\\mathbf{F}^{-1}\\) exists. The term \\(J\\) is called the relative volume change and it is equal to 1 for isochoric deformations, such as rigid body deformations. Given these properties, the deformation gradient can then be factorized into \\(\\mathbf{F} = \\mathbf{Q} \\mathbf{V}\\) , where \\(\\mathbf{V} \\succ 0\\) is the right-handed stretch tensor and \\(\\mathbf{Q} \\in \\mathrm{SO}(3)\\) is a rotation matrix belonging to the special orthogonal group 1 2 . For convenience, we summarize the derived quantities of \\(\\mathbf{F}\\) in the table below that will be used throughout this section. Relative volume change Polar decomposition Right Cauchy-Green tensor \\(J = \\det(\\mathbf{F})\\) \\(\\mathbf{F} = \\mathbf{Q} \\mathbf{V}\\) \\(\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F}\\) First strain invariant Second strain invariant Third strain invariant \\(I_1 = \\textrm{tr}(\\mathbf{C})\\) \\(I_2 = \\frac{1}{2} \\left[\\textrm{tr}(\\mathbf{C})^2 - \\textrm{tr}(\\mathbf{C}^2)\\right]\\) \\(I_3 = \\det(\\mathbf{C})\\)","title":"Intermezzo: deformation gradient"},{"location":"fem/solid/#intermezzo-derivation-of-hyperelastic-forces","text":"Let \\(\\Omega_i\\) denote the subspace spanned by the \\(i\\) -th element of the finite element mesh, and let \\(\\x_i\\) denote its nodal displacement vector. The elasticity of the constitutive soft material can be described by a strain-energy density function \\(\\Psi: \\FB \\to \\R_{\\ge 0}\\) . A comprehensive discussion on common constitutive models for \\(\\Psi\\) will be provided later in the subsequent paragraph. The elastic potential energy of the continuum body is given by \\(\\mathcal{U}_e = \\int_\\Omega \\Psi(\\cdot) \\; dV\\) , and the conservative hyper-elastic force contribution can be computed as \\(\\fB_e := \\nabla_{\\x}\\,\\mathcal{U}_e\\) . This contribution can be approximated using piecewise finite element interpolation and integrated using the Gauss quadrature rule 1 as follows: \\[ \\begin{align} \\fB_\\textrm{e}(\\x) & = \\sum_{i=1}^{N_e} \\frac{d}{d\\x_i} \\left\\{\\int_{\\Omega_i} \\Psi(\\FB(\\x_i,s)) \\; ds\\right\\}, \\\\ & \\approx \\sum_{i=1}^{N_e} \\sum_{j=1}^{N_w} w_j \\, \\underbrace{\\frac{\\p \\Psi}{\\p \\FB}(\\FB(\\x_i,s_j)) }_{\\textrm{PK1}} \\frac{\\p \\FB}{\\p \\x_i}(\\x_i,s_j) \\end{align} \\] where the Gauss weights are denoted by \\(w_j > 0\\) , and the number of finite elements and Gauss samples are represented by \\(N_e\\) and \\(N_w\\) , respectively. The term \\({\\partial \\Psi}/{\\partial \\FB}\\) is also referred to as the first Piolla-Kirchhoff (PK1) stress tensor, which can be represented in closed-form for many constitutive models. The term \\({\\partial \\FB}/{\\partial \\x_e}\\) denotes the deformation Jacobian, which can also be given in closed-form but depends on the choice of element type. In addition to the first Piolla stress tensor, we also introduce the Cauchy stress tensor (i.e., true stress) \\(\\vec{\\sigma} := J^{-1} \\frac{\\partial \\Psi}{\\partial \\FB} \\FB^\\top\\) , which is a symmetric second-order tensor whose components represent the true stress. It should be noted that these tensor calculations are highly nonlinear, making their computation the most time-consuming aspect of the finite element assembly. To enhance computational efficiency, the toolkit employs \\texttt{.mex} executable code, generated during installation (\\texttt{Matlab Coder} is required). Nam Ho Kim. Introduction Analysis Finite Element to Nonlinear . Springer, 2018. ISBN 9781441917454. \u21a9 \u21a9 \u21a9 Gerhard A. Holzapfel. Nonlinear Solid Mechanics: A Continuum Approach for Engineering Science . Volume 37. Kluwer Academic Publishers, Heidelberg, Germany, July 2002. doi:10.1023/A:1020843529530 . \u21a9 \u21a9 Breannan Smith, Fernando De Goes, and Theodore Kim. Stable neo-hookean flesh simulation. ACM Trans. Graph. , mar 2018. URL: https://doi.org/10.1145/3180491 , doi:10.1145/3180491 . \u21a9","title":"Intermezzo: Derivation of hyperelastic forces"},{"location":"fem/solvers/","text":"Solvers and eigen value decomposition To solve the structural forward dynamics of the system \\eqref{eq:C5:femmodel}, the toolkit uses an implicit Newmark- \\(\\beta\\) solver \\cite{Newmark1959Jul}, which is briefly outlined in Appendix \\ref{app:C5:newmark}. \\(\\renewcommand{\\elastic}{_\\textrm{e}}\\) \\(\\renewcommand{\\grav}{_\\textrm{g}}\\) \\(\\renewcommand{\\p}{\\partial}\\) \\(\\renewcommand{\\R}{\\mathbb{R}}\\) \\(\\renewcommand{\\vec}[1]{\\mathbf{#1}}\\) \\(\\renewcommand{\\mat}[1]{\\mathbf{#1}}\\) \\(\\renewcommand{\\FB}{\\mathbf{F}}\\) \\(\\renewcommand{\\fB}{\\mathbf{f}}\\) \\(\\renewcommand{\\Hm}{\\mathcal{H}}\\) \\(\\renewcommand{\\xB}{\\mathbf{x}}\\) \\(\\renewcommand{\\AB}{\\mathbf{A}}\\) \\(\\renewcommand{\\x}{\\mathbf{x}}\\) \\(\\renewcommand{\\dxB}{\\dot{\\mathbf{x}}}\\) \\(\\renewcommand{\\dt}{\\delta t}\\) \\(\\renewcommand{\\ddxB}{\\ddot{\\mathbf{x}}}\\) Explaination on Newmark- \\(\\beta\\) solver The Newmark- \\(\\beta\\) method is an implicit numerical integration scheme extensively used to solve high-dimensional structural dynamic problem 1 2 . We briefly explain the algorithm implemented in the function Fem.simulate . First, let us subdivide the time domain such that \\((0,...,T)\\) with uniform timesteps \\(\\dt = t_{i+1} - t_i\\) . Then, given the initial conditions, we wish to compute the state evolution \\(\\xB(t_i)\\) and \\(\\dot{\\x}(t_i)\\) . For conciseness, let us write the discrete states of the FEM model as \\(\\xB(t_i) = \\xB^{(i)}\\) . Through the extended mean value theorem, we can formulate the general Newmark- \\(\\beta\\) scheme as \\[ \\begin{align} {\\dxB}^{(i+1)} & = {\\dxB}^{(i)} + \\dt \\left[(1-\\beta_1)\\ddxB^{(i)} + \\beta_1 \\ddxB^{(i+1)} \\right], \\\\[0.2em] % {\\xB}^{(i+1)} & = {\\vec{x}}^{(i)} + {\\dt}\\left[ \\dxB^{(i)} +\\dt(\\tfrac{1}{2}-\\beta_2) \\ddxB^{(i)} + \\dt \\beta_2 \\ddxB^{(i+1)} \\right], \\end{align} \\] where \\(\\beta_1,\\beta_2 \\ge \\frac{1}{2}\\) . Now, in the expressions above only the forward-time acceleration \\(\\ddxB^{(i+1)}\\) is the unknown partial solution, hence we conveniently write \\(\\vec{w} := \\ddot{\\xB}^{(i+1)}\\) . Substitution into the flow \\eqref{eq:C5:femmodel}, we find: \\[ \\mat{r}(\\vec{w}): = \\mat{M} \\vec{w} + \\nabla_{\\xB\\,}\\mathcal{U}(\\vec{w}) + \\mat{R}\\dxB^{(i+1)}(\\vec{w}) - \\vec{G}\\vec{u}^{(i+1)}, \\label{app:C3:residual_newmark} \\] where \\(\\Hm\\) is the Hamiltonian. Following, the residual vector \\eqref{app:C3:residual_newmark} forms an optimization problem in the form \\(\\text{argmin}_{\\vec{w}} \\lVert \\vec{r}(\\vec{w}) \\rVert_2\\) for unknown accelerations \\(\\vec{w}\\) . This implicit relation can be solved numerically using a recursive Newton Raphson method. Given the \\(n\\) -th iteration, the recursive solver reads \\[ \\vec{w}^{(n+1)} = \\vec{w}^{(n)} - \\alpha_+ \\left[ \\mat{A}(\\vec{w}^{(n)}) \\right]^{-1}\\! \\vec{r}(\\vec{w}^{(n)}), \\label{eq:C3:newmark_newtonsolver} \\] where \\(\\AB := \\left[\\mat{M} + \\beta_1 \\dt \\mat{R} + \\beta_2 \\dt^2 \\mat{K}_{T}\\right]\\) is the hessian matrix, and \\(0< \\alpha_+ \\le 1\\) an update coefficient. The matrix \\(\\mat{K}_T\\) denotes the tangent stiffness related to the local gradient of the elasticity force, given by \\(\\mat{K}_T := \\nabla_{\\xB} \\fB\\elastic\\) . Implicit solvers offer improved stability compared to explicit methods, such as the Runge-Kutta solver (\\texttt{ode45}), particularly when larger time steps are employed. However, the cost of larger time steps is a decreased numerical precision. Alternatively, for quasi-static problems when \\(\\ddxB = \\dxB = \\vec{0}_n\\) , we aim to seek the solutions to the static force equilibrium \\(\\vec{r}(\\x) = \\vec{0}_n\\) where \\(\\vec{r} := -\\fB_{\\textrm{mat}} + \\fB\\grav + \\fB_\\textrm{u} + \\fB_{\\Omega_{\\textrm{env}}}\\) is the force residual vector. The nonlinear equality for nodal displacements \\(\\x\\) is solved using an iterative Newton-Raphson solver. To call these solvers, dynamic simulations are executed with \\code{fem.simulate()} and quasi-static simulations with fem.solve(). Upon completion of a simulation, all displacements, velocities, forces, and stress information are stored in the \\code{fem.Log} data structure. This log file can be accessed for data analysis or during simulation to facilitate state feedback control. Example: basic pull test 1 2 3 4 5 6 7 8 9 10 11 12 % generate mesh msh = Mesh ( sRectangle ( 20 ), 'Quads' , [ 25 , 10 ]); msh = msh . generate (); % generate fem model and boundary cond. fem = Fem ( msh , 'TimeStep' , 1 / 100 ); fem = fem . addSupport ( 'left' , [ 1 , 1 ]); fem = fem . addDisplace ( 'right' , [ 100 , 0 ]); fem = fem . addMaterial ( NeoHookean ( 1 , 0.33 )); % solve :) fem = fem . solve (); Alternatively, we can explore nonlinear modal analysis at any quasi-static equilibrium configuration \\(\\x^* \\in \\mathcal{X}\\) of the system. Let \\(\\mat{K}_T:= \\left[\\frac{\\p \\fB\\elastic}{\\p x_1} \\;...\\; \\frac{\\p \\fB\\elastic}{\\p x_2} \\right]\\) be the Jacobian matrix of the (nonlinear) elastic potential forces, also referred to as the tangent stiffness. Then, the local eigenvalue problem for the linearized FEM model around the point \\(\\x^*\\) is given by \\[ \\Big[\\mat{K}_T(\\x^*)- \\lambda_i \\mat{M} \\Big] \\vec{\\theta}_i = \\vec{0}_n, \\] where \\(\\lambda_i\\) is a real scalar eigenvalue and \\(\\vec{\\theta}_i\\) is its corresponding eigenmode. The dynamic analysis is implemented in Sorotoki using \\code{fem = fem.analysis(x)}, which stores the necessary data in \\code{fem.Log}. It is important to note that, unlike linear finite element models, the set of eigenmodes \\({\\vec{\\theta}_i}\\) obtained from the eigenvalue decomposition in \\eqref{eq:C5:eigenmode_decomposition} is highly dependent on the linearization point \\(\\x^*\\) and may thus not be unique for all \\(\\x^* \\in \\mathcal{X}\\) . Nathan M. Newmark. A Method of Computation for Structural Dynamics. Journal of the Engineering Mechanics Division , 85(3):67\u201394, 1959. doi:10.1061/JMCEA3.0000098 . \u21a9 Gerhard A. Holzapfel. Nonlinear Solid Mechanics: A Continuum Approach for Engineering Science . Volume 37. Kluwer Academic Publishers, Heidelberg, Germany, July 2002. doi:10.1023/A:1020843529530 . \u21a9","title":"Solvers and eigen value decomposition"},{"location":"fem/solvers/#solvers-and-eigen-value-decomposition","text":"To solve the structural forward dynamics of the system \\eqref{eq:C5:femmodel}, the toolkit uses an implicit Newmark- \\(\\beta\\) solver \\cite{Newmark1959Jul}, which is briefly outlined in Appendix \\ref{app:C5:newmark}. \\(\\renewcommand{\\elastic}{_\\textrm{e}}\\) \\(\\renewcommand{\\grav}{_\\textrm{g}}\\) \\(\\renewcommand{\\p}{\\partial}\\) \\(\\renewcommand{\\R}{\\mathbb{R}}\\) \\(\\renewcommand{\\vec}[1]{\\mathbf{#1}}\\) \\(\\renewcommand{\\mat}[1]{\\mathbf{#1}}\\) \\(\\renewcommand{\\FB}{\\mathbf{F}}\\) \\(\\renewcommand{\\fB}{\\mathbf{f}}\\) \\(\\renewcommand{\\Hm}{\\mathcal{H}}\\) \\(\\renewcommand{\\xB}{\\mathbf{x}}\\) \\(\\renewcommand{\\AB}{\\mathbf{A}}\\) \\(\\renewcommand{\\x}{\\mathbf{x}}\\) \\(\\renewcommand{\\dxB}{\\dot{\\mathbf{x}}}\\) \\(\\renewcommand{\\dt}{\\delta t}\\) \\(\\renewcommand{\\ddxB}{\\ddot{\\mathbf{x}}}\\) Explaination on Newmark- \\(\\beta\\) solver The Newmark- \\(\\beta\\) method is an implicit numerical integration scheme extensively used to solve high-dimensional structural dynamic problem 1 2 . We briefly explain the algorithm implemented in the function Fem.simulate . First, let us subdivide the time domain such that \\((0,...,T)\\) with uniform timesteps \\(\\dt = t_{i+1} - t_i\\) . Then, given the initial conditions, we wish to compute the state evolution \\(\\xB(t_i)\\) and \\(\\dot{\\x}(t_i)\\) . For conciseness, let us write the discrete states of the FEM model as \\(\\xB(t_i) = \\xB^{(i)}\\) . Through the extended mean value theorem, we can formulate the general Newmark- \\(\\beta\\) scheme as \\[ \\begin{align} {\\dxB}^{(i+1)} & = {\\dxB}^{(i)} + \\dt \\left[(1-\\beta_1)\\ddxB^{(i)} + \\beta_1 \\ddxB^{(i+1)} \\right], \\\\[0.2em] % {\\xB}^{(i+1)} & = {\\vec{x}}^{(i)} + {\\dt}\\left[ \\dxB^{(i)} +\\dt(\\tfrac{1}{2}-\\beta_2) \\ddxB^{(i)} + \\dt \\beta_2 \\ddxB^{(i+1)} \\right], \\end{align} \\] where \\(\\beta_1,\\beta_2 \\ge \\frac{1}{2}\\) . Now, in the expressions above only the forward-time acceleration \\(\\ddxB^{(i+1)}\\) is the unknown partial solution, hence we conveniently write \\(\\vec{w} := \\ddot{\\xB}^{(i+1)}\\) . Substitution into the flow \\eqref{eq:C5:femmodel}, we find: \\[ \\mat{r}(\\vec{w}): = \\mat{M} \\vec{w} + \\nabla_{\\xB\\,}\\mathcal{U}(\\vec{w}) + \\mat{R}\\dxB^{(i+1)}(\\vec{w}) - \\vec{G}\\vec{u}^{(i+1)}, \\label{app:C3:residual_newmark} \\] where \\(\\Hm\\) is the Hamiltonian. Following, the residual vector \\eqref{app:C3:residual_newmark} forms an optimization problem in the form \\(\\text{argmin}_{\\vec{w}} \\lVert \\vec{r}(\\vec{w}) \\rVert_2\\) for unknown accelerations \\(\\vec{w}\\) . This implicit relation can be solved numerically using a recursive Newton Raphson method. Given the \\(n\\) -th iteration, the recursive solver reads \\[ \\vec{w}^{(n+1)} = \\vec{w}^{(n)} - \\alpha_+ \\left[ \\mat{A}(\\vec{w}^{(n)}) \\right]^{-1}\\! \\vec{r}(\\vec{w}^{(n)}), \\label{eq:C3:newmark_newtonsolver} \\] where \\(\\AB := \\left[\\mat{M} + \\beta_1 \\dt \\mat{R} + \\beta_2 \\dt^2 \\mat{K}_{T}\\right]\\) is the hessian matrix, and \\(0< \\alpha_+ \\le 1\\) an update coefficient. The matrix \\(\\mat{K}_T\\) denotes the tangent stiffness related to the local gradient of the elasticity force, given by \\(\\mat{K}_T := \\nabla_{\\xB} \\fB\\elastic\\) . Implicit solvers offer improved stability compared to explicit methods, such as the Runge-Kutta solver (\\texttt{ode45}), particularly when larger time steps are employed. However, the cost of larger time steps is a decreased numerical precision. Alternatively, for quasi-static problems when \\(\\ddxB = \\dxB = \\vec{0}_n\\) , we aim to seek the solutions to the static force equilibrium \\(\\vec{r}(\\x) = \\vec{0}_n\\) where \\(\\vec{r} := -\\fB_{\\textrm{mat}} + \\fB\\grav + \\fB_\\textrm{u} + \\fB_{\\Omega_{\\textrm{env}}}\\) is the force residual vector. The nonlinear equality for nodal displacements \\(\\x\\) is solved using an iterative Newton-Raphson solver. To call these solvers, dynamic simulations are executed with \\code{fem.simulate()} and quasi-static simulations with fem.solve(). Upon completion of a simulation, all displacements, velocities, forces, and stress information are stored in the \\code{fem.Log} data structure. This log file can be accessed for data analysis or during simulation to facilitate state feedback control. Example: basic pull test 1 2 3 4 5 6 7 8 9 10 11 12 % generate mesh msh = Mesh ( sRectangle ( 20 ), 'Quads' , [ 25 , 10 ]); msh = msh . generate (); % generate fem model and boundary cond. fem = Fem ( msh , 'TimeStep' , 1 / 100 ); fem = fem . addSupport ( 'left' , [ 1 , 1 ]); fem = fem . addDisplace ( 'right' , [ 100 , 0 ]); fem = fem . addMaterial ( NeoHookean ( 1 , 0.33 )); % solve :) fem = fem . solve (); Alternatively, we can explore nonlinear modal analysis at any quasi-static equilibrium configuration \\(\\x^* \\in \\mathcal{X}\\) of the system. Let \\(\\mat{K}_T:= \\left[\\frac{\\p \\fB\\elastic}{\\p x_1} \\;...\\; \\frac{\\p \\fB\\elastic}{\\p x_2} \\right]\\) be the Jacobian matrix of the (nonlinear) elastic potential forces, also referred to as the tangent stiffness. Then, the local eigenvalue problem for the linearized FEM model around the point \\(\\x^*\\) is given by \\[ \\Big[\\mat{K}_T(\\x^*)- \\lambda_i \\mat{M} \\Big] \\vec{\\theta}_i = \\vec{0}_n, \\] where \\(\\lambda_i\\) is a real scalar eigenvalue and \\(\\vec{\\theta}_i\\) is its corresponding eigenmode. The dynamic analysis is implemented in Sorotoki using \\code{fem = fem.analysis(x)}, which stores the necessary data in \\code{fem.Log}. It is important to note that, unlike linear finite element models, the set of eigenmodes \\({\\vec{\\theta}_i}\\) obtained from the eigenvalue decomposition in \\eqref{eq:C5:eigenmode_decomposition} is highly dependent on the linearization point \\(\\x^*\\) and may thus not be unique for all \\(\\x^* \\in \\mathcal{X}\\) . Nathan M. Newmark. A Method of Computation for Structural Dynamics. Journal of the Engineering Mechanics Division , 85(3):67\u201394, 1959. doi:10.1061/JMCEA3.0000098 . \u21a9 Gerhard A. Holzapfel. Nonlinear Solid Mechanics: A Continuum Approach for Engineering Science . Volume 37. Kluwer Academic Publishers, Heidelberg, Germany, July 2002. doi:10.1023/A:1020843529530 . \u21a9","title":"Solvers and eigen value decomposition"},{"location":"mesh/mesh/","text":"Meshing ( Mesh.m ) In finite elements and computer graphics, mesh tessellation is a common language used to describe the structural geometry through a finite collection of vertices and edges. In Sorotoki , meshes and mesh generation features are packaged into the class Mesh.m . In general, a mesh defines a discrete representation of a continuum body that is subdivided into smaller convex sub-volumes, referred to as \"elements\". The nodal and elemental information are stored in data structures that can be accessed using msh.Node and msh.Element , respectively. For two-dimensional FEM problems, it is common to use linear elements such as Tri3 and Quad4 or quadratic elements like Tri6 and Quad8 $. For three-dimensional FEM problems, the common practice is to use hexahedron elements (i.e. Hex8 ) or tetrahedral elements (i.e., Tet4 and Tet12 ). There are also polygonal tessellations, often denotes as PolyN finite elements 1 . Sorotoki supports all these types. Cameron Talischi, Glaucio H. Paulino, Anderson Pereira, and Ivan F. M. Menezes. PolyTop: a Matlab implementation of a general topology optimization framework using unstructured polygonal finite element meshes. Structural and Multidisciplinary Optimization , 45(3):329\u2013357, 2012. doi:10.1007/s00158-011-0696-x . \u21a9","title":"Meshing (`Mesh.m`)"},{"location":"mesh/mesh/#meshing-meshm","text":"In finite elements and computer graphics, mesh tessellation is a common language used to describe the structural geometry through a finite collection of vertices and edges. In Sorotoki , meshes and mesh generation features are packaged into the class Mesh.m . In general, a mesh defines a discrete representation of a continuum body that is subdivided into smaller convex sub-volumes, referred to as \"elements\". The nodal and elemental information are stored in data structures that can be accessed using msh.Node and msh.Element , respectively. For two-dimensional FEM problems, it is common to use linear elements such as Tri3 and Quad4 or quadratic elements like Tri6 and Quad8 $. For three-dimensional FEM problems, the common practice is to use hexahedron elements (i.e. Hex8 ) or tetrahedral elements (i.e., Tet4 and Tet12 ). There are also polygonal tessellations, often denotes as PolyN finite elements 1 . Sorotoki supports all these types. Cameron Talischi, Glaucio H. Paulino, Anderson Pereira, and Ivan F. M. Menezes. PolyTop: a Matlab implementation of a general topology optimization framework using unstructured polygonal finite element meshes. Structural and Multidisciplinary Optimization , 45(3):329\u2013357, 2012. doi:10.1007/s00158-011-0696-x . \u21a9","title":"Meshing (Mesh.m)"},{"location":"mesh/meshdata/","text":"","title":"Meshdata"},{"location":"mesh/meshsdf/","text":"Mesh from SDFs The Sorotoki toolkit explores several routines for mesh generation, which are all contained in the class Mesh.m . Our primary focus is on using a modified version of the PolyMesher software developed by Talischi et al. 1 . Their work provided a stable foundation for generating unstructured meshes of PolyN elements. The approach starts by defining a material domain implicitly using SDFs. The number of elements is chosen a priori, and then repeated random sampling of the SDF is performed until the number of samples that fall within the specified domain matches the number of elements. A bounded Voronoi diagram is generated using the samples and the centers of the Voronoi cells are updated using Lloyd's algorithm 2 . To generate a mesh from an Sdf class, one can call msh = Mesh(Sdf) followed by msh = msh.generate() . Example: Mesh from SDF unit circle 1 2 3 4 5 6 7 8 9 10 11 12 % distance function f = @( x ) sqrt ( x (:, 1 ) .^ 2 + x (:, 2 ) .^ 2 ) - 1.0 ; % assigning @f to Sdf class sdf = Sdf ( f , 'BdBox' ,[ - 2 2 - 2 2 ]); % mesh from sdf class msh = Mesh ( sdf ); msh = msh . generate ( 'NElem' , 20 ); % show mesh msh . show (); Example: Mesh from SDF unit circle 1 2 3 4 5 6 7 8 9 10 11 % distance function c = sCircle ( .25 ); r = sRectangle ( 1 ); sdf = r . rotate ( 45 ) - c ; % mesh from sdf class msh = Mesh ( sdf , 'NElem' , 150 ); msh = msh . generate (); % show mesh msh . show (); Cameron Talischi, Glaucio H. Paulino, Anderson Pereira, and Ivan F. M. Menezes. PolyTop: a Matlab implementation of a general topology optimization framework using unstructured polygonal finite element meshes. Structural and Multidisciplinary Optimization , 45(3):329\u2013357, 2012. doi:10.1007/s00158-011-0696-x . \u21a9 S. Lloyd. Least squares quantization in PCM. IEEE Transactions on Information Theory , 28(2):129\u2013137, 1982. doi:10.1109/TIT.1982.1056489 . \u21a9","title":"Mesh from SDFs"},{"location":"mesh/meshsdf/#mesh-from-sdfs","text":"The Sorotoki toolkit explores several routines for mesh generation, which are all contained in the class Mesh.m . Our primary focus is on using a modified version of the PolyMesher software developed by Talischi et al. 1 . Their work provided a stable foundation for generating unstructured meshes of PolyN elements. The approach starts by defining a material domain implicitly using SDFs. The number of elements is chosen a priori, and then repeated random sampling of the SDF is performed until the number of samples that fall within the specified domain matches the number of elements. A bounded Voronoi diagram is generated using the samples and the centers of the Voronoi cells are updated using Lloyd's algorithm 2 . To generate a mesh from an Sdf class, one can call msh = Mesh(Sdf) followed by msh = msh.generate() . Example: Mesh from SDF unit circle 1 2 3 4 5 6 7 8 9 10 11 12 % distance function f = @( x ) sqrt ( x (:, 1 ) .^ 2 + x (:, 2 ) .^ 2 ) - 1.0 ; % assigning @f to Sdf class sdf = Sdf ( f , 'BdBox' ,[ - 2 2 - 2 2 ]); % mesh from sdf class msh = Mesh ( sdf ); msh = msh . generate ( 'NElem' , 20 ); % show mesh msh . show (); Example: Mesh from SDF unit circle 1 2 3 4 5 6 7 8 9 10 11 % distance function c = sCircle ( .25 ); r = sRectangle ( 1 ); sdf = r . rotate ( 45 ) - c ; % mesh from sdf class msh = Mesh ( sdf , 'NElem' , 150 ); msh = msh . generate (); % show mesh msh . show (); Cameron Talischi, Glaucio H. Paulino, Anderson Pereira, and Ivan F. M. Menezes. PolyTop: a Matlab implementation of a general topology optimization framework using unstructured polygonal finite element meshes. Structural and Multidisciplinary Optimization , 45(3):329\u2013357, 2012. doi:10.1007/s00158-011-0696-x . \u21a9 S. Lloyd. Least squares quantization in PCM. IEEE Transactions on Information Theory , 28(2):129\u2013137, 1982. doi:10.1109/TIT.1982.1056489 . \u21a9","title":"Mesh from SDFs"},{"location":"mesh/meshstl/","text":"Mesh from common files An alternative option is to use the mesh generation tools provided by the Partial Differential Toolbox in Matlab. Such function is also included in Mesh.generate . SDFs can also be used in this process, although an intermediate step is required. For two-dimensional domains, SDFs are first converted into binary images and then the image boundary detection is used to convert them to either a linear mesh Tri3 or a quadratic mesh Tri6 . Direct input of black-and-white .jpg or .png images is also supported. For three-dimensional domains, SDF functions are converted to an .stl file using the Marching Cube algorithm 1 and then provided to the Matlab PDE toolbox to generate the tessellation. Importing and exporting .stl or .obj files directly is also possible. Example: Mesh from image file 1 2 3 4 5 6 7 8 9 % distance function file = '+preset/assets/img/sorotoki_bwlogo.png' % generate mesh msh = Mesh ( file , 'ElementSize' , 2.5 ); msh = msh . generate ; % show mesh msh . show (); For Sorotoki to use .png / .jpg , the background must be white and foreground black! Example: Mesh from STL file 1 2 3 4 5 6 7 8 9 10 % distance function file = '+preset/assets/stl/Bunny.stl' % generate mesh msh = Mesh ( file , 'ElementSize' , 5 ); msh = msh . generate ; % show mesh msh . show (); view ( 10 , 10 ); William E. Lorensen and Harvey E. Cline. Marching cubes: A high resolution 3D surface construction algorithm. In ACM SIGGRAPH Computer Graphics , volume 21, pages 163\u2013169. Association for Computing Machinery, New York, NY, USA, 1987. doi:10.1145/37401.37422 . \u21a9","title":"Mesh from common files"},{"location":"mesh/meshstl/#mesh-from-common-files","text":"An alternative option is to use the mesh generation tools provided by the Partial Differential Toolbox in Matlab. Such function is also included in Mesh.generate . SDFs can also be used in this process, although an intermediate step is required. For two-dimensional domains, SDFs are first converted into binary images and then the image boundary detection is used to convert them to either a linear mesh Tri3 or a quadratic mesh Tri6 . Direct input of black-and-white .jpg or .png images is also supported. For three-dimensional domains, SDF functions are converted to an .stl file using the Marching Cube algorithm 1 and then provided to the Matlab PDE toolbox to generate the tessellation. Importing and exporting .stl or .obj files directly is also possible. Example: Mesh from image file 1 2 3 4 5 6 7 8 9 % distance function file = '+preset/assets/img/sorotoki_bwlogo.png' % generate mesh msh = Mesh ( file , 'ElementSize' , 2.5 ); msh = msh . generate ; % show mesh msh . show (); For Sorotoki to use .png / .jpg , the background must be white and foreground black! Example: Mesh from STL file 1 2 3 4 5 6 7 8 9 10 % distance function file = '+preset/assets/stl/Bunny.stl' % generate mesh msh = Mesh ( file , 'ElementSize' , 5 ); msh = msh . generate ; % show mesh msh . show (); view ( 10 , 10 ); William E. Lorensen and Harvey E. Cline. Marching cubes: A high resolution 3D surface construction algorithm. In ACM SIGGRAPH Computer Graphics , volume 21, pages 163\u2013169. Association for Computing Machinery, New York, NY, USA, 1987. doi:10.1145/37401.37422 . \u21a9","title":"Mesh from common files"},{"location":"mfiles/interpolateSE3/","text":"INTERPOLATESE3 - Interpolates between two SE(3) transformations. Z = interpolateSE3(X,Y,t) interpolates between two SE(3) transformations X and Y using a parameter t. The resulting transformation is returned in Z. Z = interpolateSE3(X,Y,t,varargin) allows additional options to be specified through varargin. Currently supported options are: - 'equal': Sets the velocity twist equal between X and Y. - 'zero': Sets the velocity and acceleration twist zero for X. Input: X - The initial SE(3) transformation. Y - The final SE(3) transformation. t - The interpolation parameter (between 0 and 1). varargin - Additional options for interpolation (optional). Output: Z - The interpolated SE(3) transformation. Example: H1 = SE3(rotx(0),[0,0,0]); H2 = SE3(rotx(pi/3) * roty(pi),[1,0,1]) [p1,ux1,uy1,uz1] = backbone(H1); fquiver(p1,ux1,.25,'b','LineW',3); hold on; fquiver(p1,uy1,.25,'r','LineW',3); fquiver(p1,uz1,.25,'g','LineW',3); [p2,ux2,uy2,uz2] = backbone(H2); fquiver(p2,ux2,.25,'b','LineW',3); hold on; fquiver(p2,uy2,.25,'r','LineW',3); fquiver(p2,uz2,.25,'g','LineW',3); axis equal; t = linspace(0,1,10); for ii = 2:numel(t)-1 G = interpolateSE3(H1,H2,t(ii),'zeros'); [p2,ux2,uy2,uz2] = backbone(G); fquiver(p2,ux2,.15,'b','LineW',2); hold on; fquiver(p2,uy2,.15,'r','LineW',2); fquiver(p2,uz2,.15,'g','LineW',2); end view(30,30); See also logmapSO3, expmapSO3 Reference: F.C. Park, Smooth Invariant Interpolation of Rotations.","title":"interpolateSE3"},{"location":"mfiles/interpolateSE3/#interpolatese3-interpolates-between-two-se3-transformations","text":"Z = interpolateSE3(X,Y,t) interpolates between two SE(3) transformations X and Y using a parameter t. The resulting transformation is returned in Z. Z = interpolateSE3(X,Y,t,varargin) allows additional options to be specified through varargin. Currently supported options are: - 'equal': Sets the velocity twist equal between X and Y. - 'zero': Sets the velocity and acceleration twist zero for X. Input: X - The initial SE(3) transformation. Y - The final SE(3) transformation. t - The interpolation parameter (between 0 and 1). varargin - Additional options for interpolation (optional). Output: Z - The interpolated SE(3) transformation. Example: H1 = SE3(rotx(0),[0,0,0]); H2 = SE3(rotx(pi/3) * roty(pi),[1,0,1]) [p1,ux1,uy1,uz1] = backbone(H1); fquiver(p1,ux1,.25,'b','LineW',3); hold on; fquiver(p1,uy1,.25,'r','LineW',3); fquiver(p1,uz1,.25,'g','LineW',3); [p2,ux2,uy2,uz2] = backbone(H2); fquiver(p2,ux2,.25,'b','LineW',3); hold on; fquiver(p2,uy2,.25,'r','LineW',3); fquiver(p2,uz2,.25,'g','LineW',3); axis equal; t = linspace(0,1,10); for ii = 2:numel(t)-1 G = interpolateSE3(H1,H2,t(ii),'zeros'); [p2,ux2,uy2,uz2] = backbone(G); fquiver(p2,ux2,.15,'b','LineW',2); hold on; fquiver(p2,uy2,.15,'r','LineW',2); fquiver(p2,uz2,.15,'g','LineW',2); end view(30,30); See also logmapSO3, expmapSO3 Reference: F.C. Park, Smooth Invariant Interpolation of Rotations.","title":"INTERPOLATESE3 - Interpolates between two SE(3) transformations."},{"location":"model/model/","text":"Model Composer","title":"Model Composer"},{"location":"model/model/#model-composer","text":"","title":"Model Composer"},{"location":"plotting/colormaps/","text":"Colormaps Overview fig ( 102 ,[ 10.75 , 10.75 ]); colormaplist = { 'blackwhite' , 'bluesea' , 'heatmap' , 'inferno' , 'metro' , ... 'noir' , 'turbo' , 'viridis' , 'bounce' , 'barney' , 'evolution' , ... 'rainbow' , 'polarmap' , 'redgreen' , 'soapbubble' }; N = numel ( colormaplist ); Nx = ceil ( sqrt ( N )); Ny = ceil ( sqrt ( N )); for ii = 1 : N ax = subplot ( Nx , Ny , ii ) ; colorwheel (); map = str2func ([ '@(x) ' , colormaplist { ii }]); colormap ( ax , map ([])); axis off tight ; end List of colormaps Improved colormaps of Sorotoki Colormap manipulation","title":"Colormaps"},{"location":"plotting/colormaps/#colormaps","text":"","title":"Colormaps"},{"location":"plotting/colormaps/#overview","text":"fig ( 102 ,[ 10.75 , 10.75 ]); colormaplist = { 'blackwhite' , 'bluesea' , 'heatmap' , 'inferno' , 'metro' , ... 'noir' , 'turbo' , 'viridis' , 'bounce' , 'barney' , 'evolution' , ... 'rainbow' , 'polarmap' , 'redgreen' , 'soapbubble' }; N = numel ( colormaplist ); Nx = ceil ( sqrt ( N )); Ny = ceil ( sqrt ( N )); for ii = 1 : N ax = subplot ( Nx , Ny , ii ) ; colorwheel (); map = str2func ([ '@(x) ' , colormaplist { ii }]); colormap ( ax , map ([])); axis off tight ; end List of colormaps Improved colormaps of Sorotoki","title":"Overview"},{"location":"plotting/colormaps/#colormap-manipulation","text":"","title":"Colormap manipulation"},{"location":"plotting/colors/","text":"Colors The standard color schemes are not optimized well (in my opinon). Especially when compared to the MatplotLib in Python. Therefore, Sorotoki comes equipped with a new color scheme. Improved color scheme Using Sorotoki color scheme(s) fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y ); end % magick color change sorocolor ; Improved color scheme for plotting using Sorotoki Alternative option An alternative option is to call the colors directly. We can use this using col(i) where i is the color index. The indexation is identical to the legend above. fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y , 'Color' , col ( ii )); end","title":"Colors"},{"location":"plotting/colors/#colors","text":"The standard color schemes are not optimized well (in my opinon). Especially when compared to the MatplotLib in Python. Therefore, Sorotoki comes equipped with a new color scheme.","title":"Colors"},{"location":"plotting/colors/#improved-color-scheme","text":"Using Sorotoki color scheme(s) fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y ); end % magick color change sorocolor ; Improved color scheme for plotting using Sorotoki Alternative option An alternative option is to call the colors directly. We can use this using col(i) where i is the color index. The indexation is identical to the legend above. fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y , 'Color' , col ( ii )); end","title":"Improved color scheme"},{"location":"plotting/figure/","text":"Figures Making figures in Matlab is hassle some. By default, the background is gray instead of white. The line thickness is 0.5pt instead of a prettier 1.5pt . Also the bounding box of the graphs are not 1.0pt but instead 0.5pt . And the labels are by default not using the .latex interpreter. To make matters worse, we cannot scale figure size by default -- rather a set of commands are required to adjust figure size. To solve this, we introduce the fig() command. Making a fig figure % make figure of size (2^9) x (2^9) = 512 x 512 px fig ( 101 ,[ 9 , 9 ]); ezplot (@( x ) sin ( x ^ 2 )); xlabel ( '$x$' ); ylabel ( '$\\sin(x^2)$' ); Sorotoki figure Figure of size 512x512 pixels produced using fig() How about standard Matlab? Standard matlab figure result","title":"Figures"},{"location":"plotting/figure/#figures","text":"Making figures in Matlab is hassle some. By default, the background is gray instead of white. The line thickness is 0.5pt instead of a prettier 1.5pt . Also the bounding box of the graphs are not 1.0pt but instead 0.5pt . And the labels are by default not using the .latex interpreter. To make matters worse, we cannot scale figure size by default -- rather a set of commands are required to adjust figure size. To solve this, we introduce the fig() command. Making a fig figure % make figure of size (2^9) x (2^9) = 512 x 512 px fig ( 101 ,[ 9 , 9 ]); ezplot (@( x ) sin ( x ^ 2 )); xlabel ( '$x$' ); ylabel ( '$\\sin(x^2)$' ); Sorotoki figure Figure of size 512x512 pixels produced using fig() How about standard Matlab? Standard matlab figure result","title":"Figures"},{"location":"plotting/matcap/","text":"Textures bluebase.m metal.m copper.m bubble.m egg.m","title":"Textures"},{"location":"plotting/matcap/#textures","text":"bluebase.m metal.m copper.m bubble.m egg.m","title":"Textures"},{"location":"plotting/rendering/","text":"Rendering","title":"Rendering"},{"location":"plotting/rendering/#rendering","text":"","title":"Rendering"},{"location":"sdf/gradients/","text":"SDF differentiability (normal and tangent operators) Normal computation Contrary to mesh-based geometries, \\(\\renewcommand{\\pB}{\\textbf{p}} \\renewcommand{\\yB}{\\textbf{y}} \\renewcommand{\\nB}{\\textbf{n}} \\renewcommand{\\deltaB}{\\mathbf{\\delta}}\\) signed distance functions (SDFs) possess closed-form differentials. Specifically, if \\(\\Omega\\) is a subset of \\(\\mathbb{R}^n\\) with piecewise smooth boundaries, the SDF is ( \\(i\\) ) differentiable almost everywhere, and ( \\(ii\\) ) its gradient satisfies \\(|\\nabla \\texttt{sdf}| = 1\\) . As a result, the unit-normal vector \\(\\nB(\\pB)\\) pointing away from the boundary \\(\\partial \\Omega\\) can be expressed as \\(\\nB(\\pB):= \\nabla \\texttt{sdf}(\\pB)\\) . The gradient can be estimated using a finite-difference scheme: \\[ \\nB_{i}(\\pB) \\approx \\frac{1}{\\varepsilon} \\Big[\\texttt{sdf}(\\pB + \\varepsilon \\deltaB_{i}) - \\texttt{sdf}(\\pB) \\Big], \\] where \\({\\deltaB}_{i}\\) is a vectorized Kronecker delta and \\(\\varepsilon\\) a small increment. Such finite difference routine is efficiently implemented such that the normal, tangent, and bi-normal vector computations can be called using [N,T,B] = Sdf.gradient(p) . These gradient vector computations are crucial for contact dynamics with the environment whose topology may be arbitrarily complex. Example: Normal computation of 2D Sdf 1 2 3 4 5 6 7 8 9 10 11 12 13 s = sCircle ( 1 ) - sCircle ( 1.25 ,[ - 1 , - 1 ]); s . BdBox = [ - 2 , 2 , - 2 , 2 ]; th = linspace ( - pi , pi , 10 ). ' ; R = 0.95 * sqrt ( 2 ); P = R .* [ cos ( th ), sin ( th )]; s . show ( 'Quality' , 120 ); [ N , T , B ] = s . gradient ( P ); fplot ( P , 'k.' , 'MarkerSize' , 20 ); fquiver ( P , N , 0.3 , 'color' , col ( 1 ), 'LineW' , 1.5 ); fquiver ( P , T , 0.3 , 'color' , col ( 2 ), 'LineW' , 1.5 ); Surface projections The normal vector can also be useful in finding the closest-point projection onto the surface \\(\\partial \\Omega\\) : \\[\\textrm{proj}_{\\partial \\Omega}(\\pB):= \\pB - \\texttt{sdf}(\\pB) \\cdot \\nabla \\texttt{sdf}(\\pB).\\] The projection operator is implemented as [P,d] = Sdf.project(p) , which takes a point cloud \\code{p} and returns a point cloud \\code{P} that is mapped onto the boundary of the SDF. It also returns the Euclidean distance from the surface. This can be extremely useful in simulations of soft robotic grippers for grasping, or obstacle avoidance for soft manipulators. Example: Surface projection onto 2D Sdf 1 2 3 4 5 6 7 8 9 10 11 12 s = sCircle ( 1 ) - sCircle ( 1.25 ,[ - 1 , - 1 ]); s . BdBox = [ - 2 , 2 , - 2 , 2 ]; th = random ( - pi , pi , 100 ). ' ; R = 1.25 * sqrt ( 2 ); P = R .* [ cos ( th ), sin ( th )]; s . show ( 'Quality' , 120 ); prj = s . project ( P ); fplot ( P , 'k.' , 'MarkerSize' , 20 ); fplot ( prj , 'w.' , 'MarkerSize' , 20 );","title":"SDF differentiability (normal and tangent operators)"},{"location":"sdf/gradients/#sdf-differentiability-normal-and-tangent-operators","text":"","title":"SDF differentiability (normal and tangent operators)"},{"location":"sdf/gradients/#normal-computation","text":"Contrary to mesh-based geometries, \\(\\renewcommand{\\pB}{\\textbf{p}} \\renewcommand{\\yB}{\\textbf{y}} \\renewcommand{\\nB}{\\textbf{n}} \\renewcommand{\\deltaB}{\\mathbf{\\delta}}\\) signed distance functions (SDFs) possess closed-form differentials. Specifically, if \\(\\Omega\\) is a subset of \\(\\mathbb{R}^n\\) with piecewise smooth boundaries, the SDF is ( \\(i\\) ) differentiable almost everywhere, and ( \\(ii\\) ) its gradient satisfies \\(|\\nabla \\texttt{sdf}| = 1\\) . As a result, the unit-normal vector \\(\\nB(\\pB)\\) pointing away from the boundary \\(\\partial \\Omega\\) can be expressed as \\(\\nB(\\pB):= \\nabla \\texttt{sdf}(\\pB)\\) . The gradient can be estimated using a finite-difference scheme: \\[ \\nB_{i}(\\pB) \\approx \\frac{1}{\\varepsilon} \\Big[\\texttt{sdf}(\\pB + \\varepsilon \\deltaB_{i}) - \\texttt{sdf}(\\pB) \\Big], \\] where \\({\\deltaB}_{i}\\) is a vectorized Kronecker delta and \\(\\varepsilon\\) a small increment. Such finite difference routine is efficiently implemented such that the normal, tangent, and bi-normal vector computations can be called using [N,T,B] = Sdf.gradient(p) . These gradient vector computations are crucial for contact dynamics with the environment whose topology may be arbitrarily complex. Example: Normal computation of 2D Sdf 1 2 3 4 5 6 7 8 9 10 11 12 13 s = sCircle ( 1 ) - sCircle ( 1.25 ,[ - 1 , - 1 ]); s . BdBox = [ - 2 , 2 , - 2 , 2 ]; th = linspace ( - pi , pi , 10 ). ' ; R = 0.95 * sqrt ( 2 ); P = R .* [ cos ( th ), sin ( th )]; s . show ( 'Quality' , 120 ); [ N , T , B ] = s . gradient ( P ); fplot ( P , 'k.' , 'MarkerSize' , 20 ); fquiver ( P , N , 0.3 , 'color' , col ( 1 ), 'LineW' , 1.5 ); fquiver ( P , T , 0.3 , 'color' , col ( 2 ), 'LineW' , 1.5 );","title":"Normal computation"},{"location":"sdf/gradients/#surface-projections","text":"The normal vector can also be useful in finding the closest-point projection onto the surface \\(\\partial \\Omega\\) : \\[\\textrm{proj}_{\\partial \\Omega}(\\pB):= \\pB - \\texttt{sdf}(\\pB) \\cdot \\nabla \\texttt{sdf}(\\pB).\\] The projection operator is implemented as [P,d] = Sdf.project(p) , which takes a point cloud \\code{p} and returns a point cloud \\code{P} that is mapped onto the boundary of the SDF. It also returns the Euclidean distance from the surface. This can be extremely useful in simulations of soft robotic grippers for grasping, or obstacle avoidance for soft manipulators. Example: Surface projection onto 2D Sdf 1 2 3 4 5 6 7 8 9 10 11 12 s = sCircle ( 1 ) - sCircle ( 1.25 ,[ - 1 , - 1 ]); s . BdBox = [ - 2 , 2 , - 2 , 2 ]; th = random ( - pi , pi , 100 ). ' ; R = 1.25 * sqrt ( 2 ); P = R .* [ cos ( th ), sin ( th )]; s . show ( 'Quality' , 120 ); prj = s . project ( P ); fplot ( P , 'k.' , 'MarkerSize' , 20 ); fplot ( prj , 'w.' , 'MarkerSize' , 20 );","title":"Surface projections"},{"location":"sdf/operations/","text":"SDF boolean operations By evaluating the sign of the SDF, it is possible to classify the set of points as being within or outside the boundary of the domain. This enables set operations such as union, difference, and intersection to be performed. In the signed distance package, these operations are implemented using Matlab's arithmetic operators between two or more instances of the Sdf class, including + (union), - (difference), / (intersection), * (scaling), and .* (repeating). By utilizing these set operations and a library of basic SDF primitives, it is possible to construct a wide range of complex geometries with relative ease. Subsequently, the SDFs can be transformed into a .stl file using the Marching Cube algorithm by Lorensen 1 , enabling 3D printing. This functionality is implemented in the command sdf.export . Example: 2D Bellow shape Sdf 1 2 3 4 5 6 7 8 9 10 11 12 R1 = sRectangle ([ 5 , 5 ],[ 20 , 15 ]); R2 = sRectangle ([ 0 , 0 ],[ 5 , 20 ]); C1 = sCircle ( 5 ,[ 20 , 10 ]); % adding shapes via union s = R1 + C1 ; % smoothly adding straight part S2 = s . smoothunion ( R2 , 10 ); % show S2 . showContour ( 'Quality' , 200 ); Example: Revolve and repeat Sdf shapes 1 2 3 4 5 6 7 8 9 10 11 12 % repeat 2D Sdf twice with spacing [0,20]; S2 = S2 . repeat ([ 0 , 20 ], 2 ); % revolve 2D Sdf into 3D Sdf S2 = S2 . revolve (); % generate a shell of thickness T=1.5 mm S3 = S3 . shell ( 1.5 ); % render and export Sdf shape S3 = S3 . render ( 'Quality' , 50 ); S3 . export ( 'Double_Bellow.stl' ); William E. Lorensen and Harvey E. Cline. Marching cubes: A high resolution 3D surface construction algorithm. In ACM SIGGRAPH Computer Graphics , volume 21, pages 163\u2013169. Association for Computing Machinery, New York, NY, USA, 1987. doi:10.1145/37401.37422 . \u21a9","title":"SDF boolean operations"},{"location":"sdf/operations/#sdf-boolean-operations","text":"By evaluating the sign of the SDF, it is possible to classify the set of points as being within or outside the boundary of the domain. This enables set operations such as union, difference, and intersection to be performed. In the signed distance package, these operations are implemented using Matlab's arithmetic operators between two or more instances of the Sdf class, including + (union), - (difference), / (intersection), * (scaling), and .* (repeating). By utilizing these set operations and a library of basic SDF primitives, it is possible to construct a wide range of complex geometries with relative ease. Subsequently, the SDFs can be transformed into a .stl file using the Marching Cube algorithm by Lorensen 1 , enabling 3D printing. This functionality is implemented in the command sdf.export . Example: 2D Bellow shape Sdf 1 2 3 4 5 6 7 8 9 10 11 12 R1 = sRectangle ([ 5 , 5 ],[ 20 , 15 ]); R2 = sRectangle ([ 0 , 0 ],[ 5 , 20 ]); C1 = sCircle ( 5 ,[ 20 , 10 ]); % adding shapes via union s = R1 + C1 ; % smoothly adding straight part S2 = s . smoothunion ( R2 , 10 ); % show S2 . showContour ( 'Quality' , 200 ); Example: Revolve and repeat Sdf shapes 1 2 3 4 5 6 7 8 9 10 11 12 % repeat 2D Sdf twice with spacing [0,20]; S2 = S2 . repeat ([ 0 , 20 ], 2 ); % revolve 2D Sdf into 3D Sdf S2 = S2 . revolve (); % generate a shell of thickness T=1.5 mm S3 = S3 . shell ( 1.5 ); % render and export Sdf shape S3 = S3 . render ( 'Quality' , 50 ); S3 . export ( 'Double_Bellow.stl' ); William E. Lorensen and Harvey E. Cline. Marching cubes: A high resolution 3D surface construction algorithm. In ACM SIGGRAPH Computer Graphics , volume 21, pages 163\u2013169. Association for Computing Machinery, New York, NY, USA, 1987. doi:10.1145/37401.37422 . \u21a9","title":"SDF boolean operations"},{"location":"sdf/primitives/","text":"SDF primitive library 2D Primitives sCircle.m sCircle (); % circle with radius R = 1 at (0,0) sCircle ( R ); % circle with radius R at (0,0) sCircle ( R ,[ x , y ]); % circle with radius R at (x,y) sRectangle.m sRectangle (); % square with width W = 1 at (0,0) sRectangle ( R ); % circle with radius R at (0,0) sRectangle ([ x1 , y1 ],[ x2 , y2 ]); % circle with radius R at (x,y) sStrut.m sStrut (); % strut of width 1 from (0,0) to (1,1); sStrut ([ x1 , y1 ], T ); % strut of width T from (0,0) to (x1,y1); sStrut ([ x1 , y1 ], [ x2 , y2 ], T ); % strut of width T from (x1,y1) to (x2,y2); sLine.m sLine (); % line from (0,0) to (0,-1); sLine ([ x1 , y1 ]); % line from (0,0) to (x1,y1); sLine ([ x1 , y1 ], [ x2 , y2 ], T ); % line from (x1,y1) to (x2,y2); sCup.m sCup (); % square with width W = 1 at (0,0) sCup ( R ); % cup with radius R at (0,0) sCup ( R , L ); % cup with radius R and length L sSchwartz2D.m sSchwartzD2 (); % Schwartz-D surface from (0,0) sSchwartzD2 ( N , T ); % Schwartz-D with period N*2*pi and thickness T sSchwartzD2 ( N , T , 'rotated' , true ); % rotated variation sGyroid2.m sGyroid2 (); % Gyroid surface from (0,0) sGyroid2 ( N , T ); % Gyroid with period N*2*pi and thickness T sGyroid2 ( N , T , 'rotated' , true ); % rotated variation 3D Primitives sSphere.m sSphere ( R ); % sphere with radius R at (0,0,0) sSphere ([ x , y , z ], R ); % sphere with radius R at (x,y,z) sSphere ([ x , y , z ], R , T ); % shell sphere with radius R at (x,y,z) with thickness T sCube.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]); sCylinder.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]); sTorus.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]);","title":"SDF primitive library"},{"location":"sdf/primitives/#sdf-primitive-library","text":"","title":"SDF primitive library"},{"location":"sdf/primitives/#2d-primitives","text":"sCircle.m sCircle (); % circle with radius R = 1 at (0,0) sCircle ( R ); % circle with radius R at (0,0) sCircle ( R ,[ x , y ]); % circle with radius R at (x,y) sRectangle.m sRectangle (); % square with width W = 1 at (0,0) sRectangle ( R ); % circle with radius R at (0,0) sRectangle ([ x1 , y1 ],[ x2 , y2 ]); % circle with radius R at (x,y) sStrut.m sStrut (); % strut of width 1 from (0,0) to (1,1); sStrut ([ x1 , y1 ], T ); % strut of width T from (0,0) to (x1,y1); sStrut ([ x1 , y1 ], [ x2 , y2 ], T ); % strut of width T from (x1,y1) to (x2,y2); sLine.m sLine (); % line from (0,0) to (0,-1); sLine ([ x1 , y1 ]); % line from (0,0) to (x1,y1); sLine ([ x1 , y1 ], [ x2 , y2 ], T ); % line from (x1,y1) to (x2,y2); sCup.m sCup (); % square with width W = 1 at (0,0) sCup ( R ); % cup with radius R at (0,0) sCup ( R , L ); % cup with radius R and length L sSchwartz2D.m sSchwartzD2 (); % Schwartz-D surface from (0,0) sSchwartzD2 ( N , T ); % Schwartz-D with period N*2*pi and thickness T sSchwartzD2 ( N , T , 'rotated' , true ); % rotated variation sGyroid2.m sGyroid2 (); % Gyroid surface from (0,0) sGyroid2 ( N , T ); % Gyroid with period N*2*pi and thickness T sGyroid2 ( N , T , 'rotated' , true ); % rotated variation","title":"2D Primitives"},{"location":"sdf/primitives/#3d-primitives","text":"sSphere.m sSphere ( R ); % sphere with radius R at (0,0,0) sSphere ([ x , y , z ], R ); % sphere with radius R at (x,y,z) sSphere ([ x , y , z ], R , T ); % shell sphere with radius R at (x,y,z) with thickness T sCube.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]); sCylinder.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]); sTorus.m sCube ( W ); sCube ( W , L , H ); sCube ([ x1 , y1 , z1 ], W , L , H ); sCube ([ x1 , y1 , z1 ], [ x2 , y2 , z2 ]);","title":"3D Primitives"},{"location":"sdf/sdf/","text":"Signed Distance ( Sdf.m ) Signed Distance Fields (SDFs) have been widely applied in various areas of computer graphics, including the representation of implicit surfaces 1 2 , collision detection in robotics 3 4 . In particular, SDFs have gained attention for their use in implicit modeling 5 , a technique for representing 3D shapes as continuous functions, rather than discrete mesh descriptions. In Sorotoki, SDFs are implemented in the class Sdf.m and can be used to construct general 2D and 3D geometries. They can also be utilized to model static or dynamic contact environments, generate 3D models of soft actuators that are suitable for 3D printing, and compute inertia tensors for continuum bodies in \\(\\mathbb{R}^2\\) and \\(\\mathbb{R}^3\\) . Implicit modeling using SDFs. We briefly outline the mathematical foundations underpinning the Sdf class. As the name suggests, signed distance functions are a type of function that encodes distance information relative to an object defined implicitly. Adopting the notation used in Reiner 1 , given a domain \\(\\Omega \\subset \\mathbb{R}^n\\) and its boundary \\(\\partial \\Omega\\) , these functions can be written in the following general form: \\[ \\renewcommand{\\pB}{\\textbf{p}} \\renewcommand{\\yB}{\\textbf{y}} \\texttt{sdf}(\\pB) = \\begin{cases} -d(\\pB,\\Omega) & \\textrm{if } \\; \\pB \\in \\Omega, \\\\ +d(\\pB,\\Omega) & \\textrm{if } \\; \\pB \\in \\mathbb{R}^n\\!\\setminus\\! \\Omega, \\end{cases} \\label{eq:C5:sdf} \\] where \\(d(\\pB,\\Omega):= \\inf_{\\yB \\in \\Omega} ||\\pB - \\yB||_2\\) is a scalar function that returns the smallest Euclidean distance from a sample point \\(\\pB \\in \\mathbb{R}^n\\) to the boundary \\(\\partial \\Omega\\) . SDFs provide a simple and efficient way of determining the location of a set of points relative to a domain \\(\\Omega\\) defined implicitly. The SDF is a scalar function that encodes the Euclidean distance of a sample point \\(\\pB \\in \\mathbb{R}^n\\) to the boundary \\(\\partial \\Omega\\) of the domain. By evaluating the sign of the SDF, it is possible to classify the set of points as being within or outside the boundary of the domain. This enables set operations such as union, difference, and intersection to be performed. Example: Unit-circle and evaluation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 % distance function f = @( x ) sqrt ( x (:, 1 ) .^ 2 + x (:, 2 ) .^ 2 ) - 1.0 ; % assigning @f to Sdf class sdf = Sdf ( f , 'BdBox' ,[ - 2 2 - 2 2 ]); % generate samples X = linspacen ([ 0 ; 0 ],[ 1 ; 1 ], 5 ). ' ; % eval SDF D = S . eval ( X ); disp ( D (:, end ). ' ); sdf . show (); fplot ( X , 'k.' , 'MarkerSize' , 30 ); output - 1.0000 , - 0.6464 , - 0.2929 , 0.0607 , 0.4142 Example: Unit-circle intersect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 % distance function f = @( x ) sqrt ( x (:, 1 ) .^ 2 + x (:, 2 ) .^ 2 ) - 1.0 ; % assigning @f to Sdf class sdf = Sdf ( f , 'BdBox' ,[ - 2 2 - 2 2 ]); % generate samples X = linspacen ([ 0 ; 0 ],[ 1 ; 1 ], 5 ). ' ; % eval SDF I = sdf . intersect ( X ); sdf . show (); fplot ( X ( I ,:), 'm.' , 'MarkerSize' , 30 ); fplot ( X ( ~ I ,:), 'k.' , 'MarkerSize' , 30 ); Tim Reiner, Gregor M\\ifmmode \\ddot u\\else \u00fc\\fi ckl, and Carsten Dachsbacher. Interactive modeling of implicit surfaces using a direct visualization approach with signed distance functions. Computers & Graphics , 35(3):596\u2013603, 2011. doi:10.1016/j.cag.2011.03.010 . \u21a9 \u21a9 Zhiqin Chen and Hao Zhang. Learning Implicit Fields for Generative Shape Modeling. ArXiv e-prints , 2018. arXiv:1812.02822 , doi:10.48550/arXiv.1812.02822 . \u21a9 Joseph Ortiz, Alexander Clegg, Jing Dong, Edgar Sucar, David Novotny, Michael Zollhoefer, and Mustafa Mukadam. iSDF: Real-Time Neural Signed Distance Fields for Robot Perception. ArXiv e-prints , 2022. arXiv:2204.02296 , doi:10.48550/arXiv.2204.02296 . \u21a9 Puze Liu, Kuo Zhang, Davide Tateo, Snehal Jauhri, Jan Peters, and Georgia Chalvatzaki. Regularized Deep Signed Distance Fields for Reactive Motion Generation. ArXiv e-prints , 2022. arXiv:2203.04739 , doi:10.48550/arXiv.2203.04739 . \u21a9 Lawrence Smith and Robert MacCurdy. SoRoForge: End-to-End Soft Actuator Design. IEEE Transactions on Automation Science and Engineering , pages 1\u201312, 2023. doi:10.1109/TASE.2023.3241866 . \u21a9","title":"Signed Distance (`Sdf.m`)"},{"location":"sdf/sdf/#signed-distance-sdfm","text":"Signed Distance Fields (SDFs) have been widely applied in various areas of computer graphics, including the representation of implicit surfaces 1 2 , collision detection in robotics 3 4 . In particular, SDFs have gained attention for their use in implicit modeling 5 , a technique for representing 3D shapes as continuous functions, rather than discrete mesh descriptions. In Sorotoki, SDFs are implemented in the class Sdf.m and can be used to construct general 2D and 3D geometries. They can also be utilized to model static or dynamic contact environments, generate 3D models of soft actuators that are suitable for 3D printing, and compute inertia tensors for continuum bodies in \\(\\mathbb{R}^2\\) and \\(\\mathbb{R}^3\\) .","title":"Signed Distance (Sdf.m)"},{"location":"sdf/sdf/#implicit-modeling-using-sdfs","text":"We briefly outline the mathematical foundations underpinning the Sdf class. As the name suggests, signed distance functions are a type of function that encodes distance information relative to an object defined implicitly. Adopting the notation used in Reiner 1 , given a domain \\(\\Omega \\subset \\mathbb{R}^n\\) and its boundary \\(\\partial \\Omega\\) , these functions can be written in the following general form: \\[ \\renewcommand{\\pB}{\\textbf{p}} \\renewcommand{\\yB}{\\textbf{y}} \\texttt{sdf}(\\pB) = \\begin{cases} -d(\\pB,\\Omega) & \\textrm{if } \\; \\pB \\in \\Omega, \\\\ +d(\\pB,\\Omega) & \\textrm{if } \\; \\pB \\in \\mathbb{R}^n\\!\\setminus\\! \\Omega, \\end{cases} \\label{eq:C5:sdf} \\] where \\(d(\\pB,\\Omega):= \\inf_{\\yB \\in \\Omega} ||\\pB - \\yB||_2\\) is a scalar function that returns the smallest Euclidean distance from a sample point \\(\\pB \\in \\mathbb{R}^n\\) to the boundary \\(\\partial \\Omega\\) . SDFs provide a simple and efficient way of determining the location of a set of points relative to a domain \\(\\Omega\\) defined implicitly. The SDF is a scalar function that encodes the Euclidean distance of a sample point \\(\\pB \\in \\mathbb{R}^n\\) to the boundary \\(\\partial \\Omega\\) of the domain. By evaluating the sign of the SDF, it is possible to classify the set of points as being within or outside the boundary of the domain. This enables set operations such as union, difference, and intersection to be performed. Example: Unit-circle and evaluation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 % distance function f = @( x ) sqrt ( x (:, 1 ) .^ 2 + x (:, 2 ) .^ 2 ) - 1.0 ; % assigning @f to Sdf class sdf = Sdf ( f , 'BdBox' ,[ - 2 2 - 2 2 ]); % generate samples X = linspacen ([ 0 ; 0 ],[ 1 ; 1 ], 5 ). ' ; % eval SDF D = S . eval ( X ); disp ( D (:, end ). ' ); sdf . show (); fplot ( X , 'k.' , 'MarkerSize' , 30 ); output - 1.0000 , - 0.6464 , - 0.2929 , 0.0607 , 0.4142 Example: Unit-circle intersect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 % distance function f = @( x ) sqrt ( x (:, 1 ) .^ 2 + x (:, 2 ) .^ 2 ) - 1.0 ; % assigning @f to Sdf class sdf = Sdf ( f , 'BdBox' ,[ - 2 2 - 2 2 ]); % generate samples X = linspacen ([ 0 ; 0 ],[ 1 ; 1 ], 5 ). ' ; % eval SDF I = sdf . intersect ( X ); sdf . show (); fplot ( X ( I ,:), 'm.' , 'MarkerSize' , 30 ); fplot ( X ( ~ I ,:), 'k.' , 'MarkerSize' , 30 ); Tim Reiner, Gregor M\\ifmmode \\ddot u\\else \u00fc\\fi ckl, and Carsten Dachsbacher. Interactive modeling of implicit surfaces using a direct visualization approach with signed distance functions. Computers & Graphics , 35(3):596\u2013603, 2011. doi:10.1016/j.cag.2011.03.010 . \u21a9 \u21a9 Zhiqin Chen and Hao Zhang. Learning Implicit Fields for Generative Shape Modeling. ArXiv e-prints , 2018. arXiv:1812.02822 , doi:10.48550/arXiv.1812.02822 . \u21a9 Joseph Ortiz, Alexander Clegg, Jing Dong, Edgar Sucar, David Novotny, Michael Zollhoefer, and Mustafa Mukadam. iSDF: Real-Time Neural Signed Distance Fields for Robot Perception. ArXiv e-prints , 2022. arXiv:2204.02296 , doi:10.48550/arXiv.2204.02296 . \u21a9 Puze Liu, Kuo Zhang, Davide Tateo, Snehal Jauhri, Jan Peters, and Georgia Chalvatzaki. Regularized Deep Signed Distance Fields for Reactive Motion Generation. ArXiv e-prints , 2022. arXiv:2203.04739 , doi:10.48550/arXiv.2203.04739 . \u21a9 Lawrence Smith and Robert MacCurdy. SoRoForge: End-to-End Soft Actuator Design. IEEE Transactions on Automation Science and Engineering , pages 1\u201312, 2023. doi:10.1109/TASE.2023.3241866 . \u21a9","title":"Implicit modeling using SDFs."},{"location":"shapes/shapes/","text":"Beam models","title":"Beam models"},{"location":"shapes/shapes/#beam-models","text":"","title":"Beam models"},{"location":"sorobots/softhand/","text":"Soft Robotic Hand About The Sorotoki toolkit provides a soft robotic hand with a higher level of complexity compared to the previous soft robots (see above). This design is inspired by the work of Laake et al. 1 and Fras et al. 2 . The soft robotic hand consists of five independently controlled soft fingers that can be actuated using pneumatics or fluidics. Each finger is fabricated using a SLS technique with Elastic 80A, while the base is fabricated using FDM with PLA. The dimensions and scale of the soft robotic hand are similar to those of a human hand, with approximate dimensions of 190 \\(\\times\\) 100 \\(\\times\\) 40 mm. All fingers have a length of 90 mm except for the thumb, which is slightly shorter at 80 mm. The soft robotic hand has five independent inputs that accept pressures of \\(-10 \\le u \\le 60\\) kPa. Fabrication details The soft hand is fully printable. Below, we provided a list of the printer materials. 4 \\(\\times\\) : Soft Finger - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Soft Thumb - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Finger Connector - Rigid 10k - Formlabs (recommended) 1 \\(\\times\\) : Rigid Palm - Prusament PLA White - Prusa (optional) 1 \\(\\times\\) : Rigid Base - Prusament PLA White - Prusa (optional) Printing of Elastic 80A When printing Elastic 80A, the recommended supports for the material are very thick -- thus difficult to remove. We recommend generating the supports using Rigid 10K , then change the material to Elastic 80A . Support can then be easily removed manually (no pliers required). Cleaning and closing of Soft Actuators A crucial step is cleaning of the elastic resin parts. If residual resin is not properly removed/cleaned, it will greatly affect the quality and performance of the soft actuator. We recommend following the cleaning procedures proposed in Proper et al. 1 , see Git documentation . The paper draft can be found here: Paper.pdf . In their approach, a perastaltic pump is used to pump cleaning fluid through the soft actuator prior to curing. To allow fluid to flow, both sides of the soft actuator are open! They must be closed using 3 mm plug printed from the same material! The plug can be glued in place using uncured resin, and then placed in an UV chamber for a short duration. Connecting Soft Actuator to Rigid Connector Similar to closing of the soft actuators, uncured resin can be used to make a robust connection to the rigid pressure connector. This greatly improves air-tightness of the complete system. Downloadable content Complete Soft Robot Hand - uncompressed 14.3 MB (zip) Rigid Palm (STL) Rigid Base (STL) Finger Connector (STL) Soft Finger(s) (STL) Soft Thumb (STL) 3D Visualization var iframe = document.getElementById( 'api-frame' ); var uid = 'f8ffac8550114147bf9483dd2c8edb72'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } ); Bibliography Lucas C. van Laake, Jelle de Vries, Sevda Malek Kani, and Johannes T. B. Overvelde. A fluidic relaxation oscillator for reprogrammable sequential actuation in soft robots. Matter , 5(9):2898\u20132917, 2022. doi:10.1016/j.matt.2022.06.002 . \u21a9 \u21a9 Jan Fras and Kaspar Althoefer. Soft Biomimetic Prosthetic Hand: Design, Manufacturing and Preliminary Examination. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) , pages 1\u20136. IEEE, 2018. doi:10.1109/IROS.2018.8593666 . \u21a9","title":"Soft Robotic Hand"},{"location":"sorobots/softhand/#soft-robotic-hand","text":"","title":"Soft Robotic Hand"},{"location":"sorobots/softhand/#about","text":"The Sorotoki toolkit provides a soft robotic hand with a higher level of complexity compared to the previous soft robots (see above). This design is inspired by the work of Laake et al. 1 and Fras et al. 2 . The soft robotic hand consists of five independently controlled soft fingers that can be actuated using pneumatics or fluidics. Each finger is fabricated using a SLS technique with Elastic 80A, while the base is fabricated using FDM with PLA. The dimensions and scale of the soft robotic hand are similar to those of a human hand, with approximate dimensions of 190 \\(\\times\\) 100 \\(\\times\\) 40 mm. All fingers have a length of 90 mm except for the thumb, which is slightly shorter at 80 mm. The soft robotic hand has five independent inputs that accept pressures of \\(-10 \\le u \\le 60\\) kPa.","title":"About"},{"location":"sorobots/softhand/#fabrication-details","text":"The soft hand is fully printable. Below, we provided a list of the printer materials. 4 \\(\\times\\) : Soft Finger - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Soft Thumb - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Finger Connector - Rigid 10k - Formlabs (recommended) 1 \\(\\times\\) : Rigid Palm - Prusament PLA White - Prusa (optional) 1 \\(\\times\\) : Rigid Base - Prusament PLA White - Prusa (optional) Printing of Elastic 80A When printing Elastic 80A, the recommended supports for the material are very thick -- thus difficult to remove. We recommend generating the supports using Rigid 10K , then change the material to Elastic 80A . Support can then be easily removed manually (no pliers required). Cleaning and closing of Soft Actuators A crucial step is cleaning of the elastic resin parts. If residual resin is not properly removed/cleaned, it will greatly affect the quality and performance of the soft actuator. We recommend following the cleaning procedures proposed in Proper et al. 1 , see Git documentation . The paper draft can be found here: Paper.pdf . In their approach, a perastaltic pump is used to pump cleaning fluid through the soft actuator prior to curing. To allow fluid to flow, both sides of the soft actuator are open! They must be closed using 3 mm plug printed from the same material! The plug can be glued in place using uncured resin, and then placed in an UV chamber for a short duration. Connecting Soft Actuator to Rigid Connector Similar to closing of the soft actuators, uncured resin can be used to make a robust connection to the rigid pressure connector. This greatly improves air-tightness of the complete system.","title":"Fabrication details"},{"location":"sorobots/softhand/#downloadable-content","text":"Complete Soft Robot Hand - uncompressed 14.3 MB (zip) Rigid Palm (STL) Rigid Base (STL) Finger Connector (STL) Soft Finger(s) (STL) Soft Thumb (STL)","title":"Downloadable content"},{"location":"sorobots/softhand/#3d-visualization","text":"var iframe = document.getElementById( 'api-frame' ); var uid = 'f8ffac8550114147bf9483dd2c8edb72'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } );","title":"3D Visualization"},{"location":"sorobots/softhand/#bibliography","text":"Lucas C. van Laake, Jelle de Vries, Sevda Malek Kani, and Johannes T. B. Overvelde. A fluidic relaxation oscillator for reprogrammable sequential actuation in soft robots. Matter , 5(9):2898\u20132917, 2022. doi:10.1016/j.matt.2022.06.002 . \u21a9 \u21a9 Jan Fras and Kaspar Althoefer. Soft Biomimetic Prosthetic Hand: Design, Manufacturing and Preliminary Examination. In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) , pages 1\u20136. IEEE, 2018. doi:10.1109/IROS.2018.8593666 . \u21a9","title":"Bibliography"},{"location":"sorobots/softmanipulator/","text":"Soft Manipulator About The Sorotoki toolkit provides a soft robotic manipulator that features three independent bellow networks and a three-fingered soft robotic gripper attached to the end effector (see above). With independent actuation of each bellow network, the manipulator has a full 3D workspace of approximately 150 \\(\\times\\) 150 \\(\\times\\) 150 mm. The soft elements of the manipulator are fabricated using Elastic 80A resin, while the rigid connector pieces are made using Rigid 10K resin. The gripper has demonstrated the ability to successfully grip objects with a diameter of 40mm, with a maximum payload of 100g without significant parasitic deformation. The central axis of the manipulator is designed to be hollow, enabling the pneumatic tubing of the gripper and the cables for state estimation sensors (e.g. IMUs) to be embedded. The manipulator has three inputs that accepts \\(-10 \\le u \\le 30\\) kPa, and the gripper has one input port that accepts \\(-30 \\le u \\le 60\\) kPa. Fabrication details The soft manipulator is fully printable. Below, we provided a list of the printer materials. 1 \\(\\times\\) : Soft Bellow - Elastic 80A - Formlabs (recommended) 3 \\(\\times\\) : Soft Finger - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Connector One-way - Rigid 10k - Formlabs (optional) 1 \\(\\times\\) : Connector Three-way - Rigid 10k - Formlabs (optional) 1 \\(\\times\\) : Base mount M6 - Prusament PLA Azure - Prusa (optional) Printing of Elastic 80A When printing Elastic 80A, the recommended supports for the material are very thick -- thus difficult to remove. We recommend generating the supports using Rigid 10K , then change the material to Elastic 80A . Support can then be easily removed manually (no pliers required). Cleaning and closing of Soft Actuators A crucial step is cleaning of the elastic resin parts. If residual resin is not properly removed/cleaned, it will greatly affect the quality and performance of the soft actuator. We recommend following the cleaning procedures proposed in Proper et al. 1 , see Git documentation . The paper draft can be found here: Paper.pdf . In their approach, a perastaltic pump is used to pump cleaning fluid through the soft actuator prior to curing. To allow fluid to flow, both sides of the soft actuator are open! They must be closed using 3 mm plug printed from the same material! The plug can be glued in place using uncured resin, and then placed in an UV chamber for a short duration. Connecting Soft Actuator to Rigid Connector Similar to closing of the soft actuators, uncured resin can be used to make a robust connection to the rigid pressure connector. This greatly improves air-tightness of the complete system. Downloadable content Complete Soft Robot Manipulator - 14.6 MB uncompressed (.zip) Soft Bellow (STL) Soft Finger (STL) Connector One-way (STL) Connector Three-way (STL) Base mount M6 (STL) 3D Visualization var iframe = document.getElementById( 'api-frame' ); var uid = '3fd62289149f4145856b9c664c033917'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } ); Proper. B, Caasenbrood, B., & I. Kuling (2023). Easy Cleaning of 3D SLA/DLP Printed Soft Fluidic Actuators with Complex Internal Geometry. 6th IEEE International Conference on Soft Robotics, RoboSoft 2023. (submitted). https://github.com/ReshapeTUe/Peristaltic-Pump-Documentation \u21a9","title":"Soft Manipulator"},{"location":"sorobots/softmanipulator/#soft-manipulator","text":"","title":"Soft Manipulator"},{"location":"sorobots/softmanipulator/#about","text":"The Sorotoki toolkit provides a soft robotic manipulator that features three independent bellow networks and a three-fingered soft robotic gripper attached to the end effector (see above). With independent actuation of each bellow network, the manipulator has a full 3D workspace of approximately 150 \\(\\times\\) 150 \\(\\times\\) 150 mm. The soft elements of the manipulator are fabricated using Elastic 80A resin, while the rigid connector pieces are made using Rigid 10K resin. The gripper has demonstrated the ability to successfully grip objects with a diameter of 40mm, with a maximum payload of 100g without significant parasitic deformation. The central axis of the manipulator is designed to be hollow, enabling the pneumatic tubing of the gripper and the cables for state estimation sensors (e.g. IMUs) to be embedded. The manipulator has three inputs that accepts \\(-10 \\le u \\le 30\\) kPa, and the gripper has one input port that accepts \\(-30 \\le u \\le 60\\) kPa.","title":"About"},{"location":"sorobots/softmanipulator/#fabrication-details","text":"The soft manipulator is fully printable. Below, we provided a list of the printer materials. 1 \\(\\times\\) : Soft Bellow - Elastic 80A - Formlabs (recommended) 3 \\(\\times\\) : Soft Finger - Elastic 80A - Formlabs (recommended) 1 \\(\\times\\) : Connector One-way - Rigid 10k - Formlabs (optional) 1 \\(\\times\\) : Connector Three-way - Rigid 10k - Formlabs (optional) 1 \\(\\times\\) : Base mount M6 - Prusament PLA Azure - Prusa (optional) Printing of Elastic 80A When printing Elastic 80A, the recommended supports for the material are very thick -- thus difficult to remove. We recommend generating the supports using Rigid 10K , then change the material to Elastic 80A . Support can then be easily removed manually (no pliers required). Cleaning and closing of Soft Actuators A crucial step is cleaning of the elastic resin parts. If residual resin is not properly removed/cleaned, it will greatly affect the quality and performance of the soft actuator. We recommend following the cleaning procedures proposed in Proper et al. 1 , see Git documentation . The paper draft can be found here: Paper.pdf . In their approach, a perastaltic pump is used to pump cleaning fluid through the soft actuator prior to curing. To allow fluid to flow, both sides of the soft actuator are open! They must be closed using 3 mm plug printed from the same material! The plug can be glued in place using uncured resin, and then placed in an UV chamber for a short duration. Connecting Soft Actuator to Rigid Connector Similar to closing of the soft actuators, uncured resin can be used to make a robust connection to the rigid pressure connector. This greatly improves air-tightness of the complete system.","title":"Fabrication details"},{"location":"sorobots/softmanipulator/#downloadable-content","text":"Complete Soft Robot Manipulator - 14.6 MB uncompressed (.zip) Soft Bellow (STL) Soft Finger (STL) Connector One-way (STL) Connector Three-way (STL) Base mount M6 (STL)","title":"Downloadable content"},{"location":"sorobots/softmanipulator/#3d-visualization","text":"var iframe = document.getElementById( 'api-frame' ); var uid = '3fd62289149f4145856b9c664c033917'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } ); Proper. B, Caasenbrood, B., & I. Kuling (2023). Easy Cleaning of 3D SLA/DLP Printed Soft Fluidic Actuators with Complex Internal Geometry. 6th IEEE International Conference on Soft Robotics, RoboSoft 2023. (submitted). https://github.com/ReshapeTUe/Peristaltic-Pump-Documentation \u21a9","title":"3D Visualization"}]}