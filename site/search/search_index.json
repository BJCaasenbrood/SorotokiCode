{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sorotoki - a MATLAB toolkit for soft robotics Sorotoki v3.0.01 stable (Code) Sorobots v1.0 (Soft robot STL) Github page is still under construction. Not all documentation is present at the this stage of development. About Sorotoki Sorotoki is an open-source MATLAB toolkit for soft robotics that includes an array of tools for design, modeling, and control. Due to its scientific diversity, it can be challenging for new researchers to quickly familiarize themselves with multiple scientific areas. With the aim to lower this threshold, Sorotoki aims to incorporate multiple layers of soft robotics research into one compact toolkit. Examples include: continuum mechanics, dynamic systems and control theory, topology optimization, computer graphics, and much more to come! The combination provides a highly flexible programming environment and will hopefully aid the development of novel soft robotic research. What can Sorotoki do? Sorotoki started out small, but at its current state, it contains a vast collection of functionalities -- tailored towards many aspects of soft robotics. For example, suppose you are inspired by the multi-gait soft crawler developed by Shepard et al. 1 -- See video . Or you want to simulate the incredibly dexterous soft gripper developed by Suzumori et al. 2 -- See video . Can we model such systems easily? Well.... Short answer: no . As matter of fact, simplifying the (infinite-dimensional) dynamics of soft robots is no easy feat. It has been an active topic of research for the better part of the last two decades. Ironically, studying \"soft\" robotics is incredibly \"hard\" . Sorotoki, however, can simplify the process of design, modeling and control for soft robots. Our aim is to make research into soft robotics more accessable by dividing the problem into smaller, more manageable steps. Multi-physics solvers are included into Sorotoki and can accesses with minimal programming complexity. Simulation of multi-gait crawling soft robot undergoing an undulating motion. The model is inspired by the work of Shepard et al. (2011). Original soft robot can be found here: Youtube video Simulation of multi-finger soft gripper grasping a beaker and manipulating a M10 boltscrew. The model is inspired by the work of Suzumori et al. (1989). Original soft gripper can be found here: Youtube video Is it easy to code? Well, absolutely! List of functionalities To summarize, some of the functionalities included in the toolkit are listed below: Design: Implicit modeling using signed distance functions (SDFs), 2D-3D mesh generation, computational design using gradient-based optimization Modeling: Finite Element Models (FEM), high-efficiency reduced-order soft beam models (Lagrangian or port-Hamiltonian), easy programmable interconnections of a network of dynamical (soft robot) systems Control: Real-time (pneumatic) control platform using Raspberry Pi, vision-based sensing algorithms using Intel Realsense Depth camera Visualization: Fast and responsive 3D graphics rendering, mesh deformation modifiers (scaling, rotation, bending, twisting, mirroring), Forward Kinematic/Inverse Kinematic-rigging Accessibility: Minimal programming environment (i.e, focused on expressing complex problems with minimal lines of code). Open hardware: Four 3D-printable soft robots (e.g., soft hand, soft manipulator), and control interface). Short examples Example 1: PneuNet deformations A classic example in soft robotics is the PneuNet soft bending actuator. The PneuNet (pneumatic network) belongs to a class of soft actuators that, due to a geometrically induced stiffness differential, undergoes bending when pressurized. The geometry of the PneuNet is developed (and popularized) by Mosadegh et al. 3 , but historically it is much older 4 . To model the PneuNet actuator, consider the following numerical example. Assuming plane strain , we can simulate the nonlinear bending characteristics of the Pneunet actuator using the super-short code below (only 10 lines of code!): Code for simulation % generate mesh from image msh = Mesh ( 'Pneunet.png' , ... 'ElementSize' , 1 , ... 'BdBox' , [ 0 , 120 , 0 , 20 ]); % finite element solver (FEM) fem = Fem ( msh , 'Material' , NeoHookean ( 1.0 , 0.4 ), ... 'TimeStep' , 1e-2 ); % boundary conditions fem = fem . addGravity (); fem = fem . addPressure ( 'All' , 30 * kpa ); fem = fem . addConstraint ( 'Left' , [ 1 , 1 ]); % magic fem = fem . solve (); % take away message: simplicity > complexity Code for plotting Once a simulation is completed, there exist simple command to export the simulation as a .gif file. We can simple use the command below. This sets the frames-per-second (FPS), the axis for the replay video, and gif = true to make a gif file. fem . replay ( 'fps' , 60 , ... 'axis' ,[ - 33 , 120 - 86 21 ], ... 'gif' , true ) Example 2: Fitting hyper-elastic materials Example 3: Task-space controller for soft manipulator The next example shows the implementation of model-based controllers in Sorotoki. Consider a soft tentacle of length \\(L = 100\\) mm, radius \\(R = 5\\) mm, and a tapering of \\(75\\%\\) . We assume the tentacle is composed of DragonSkin10A silicone. \\[\\tau = J_v(q)^\\top\\left[k_p (X_d - X) - k_d \\dot{X}\\right] + \\nabla_q \\mathcal{V}\\] where \\(J_v(q) := \\lfloor J(q,L) \\rfloor_3\\) is the linear velocity part of the manipulator Jacobian matrix at the tip ( \\(\\sigma = L\\) ), \\(\\nabla_q \\mathcal{V}\\) is simply the gradient of the potential energy w.r.t to its states \\(q\\) , \\(X\\) and \\(X_d\\) the end-effector position and the desired position, respectively. Note that we can compute the end-effector velocity by \\(\\dot{X} = J_v(q) \\dot{q}\\) . Code for simulation % CODE: Example 2 -- Task-space controller % assign desired setpoint Xd = [ 30 ; 10 ; 10 ]; % build continuum shape POD = chebyspace ( 60 , 3 ); % POD basis shp = Shapes ( POD ,[ 0 , 3 , 3 , 0 , 0 , 0 ], ... % pure bending XY 'Length' , 100 , ... 'Material' , Dragonskin10 ); % geometry and boundary conditions shp = shp . setRadius ( 5 ); % R = 5 mm shp = shp . setRamp ( 0.75 ); % R is reduced by 75% at s=L shp = shp . addGravity (); % model composer mdl = Model ( shp , 'TimeStep' , 1 / 60 , ... 'Controller' , @( x ) tau ( x , Xd ) ); % magic ;) mdl = mdl . simulate (); % task-space controller (called by solver) function tau = tau ( mdl,Xd ) log = mdl . Systems { 1 }. Log ; X = log . FK . g ( 1 : 3 , 4 , end ); Jv = log . FK . J ( 4 : 6 ,:, end ); Vq = log . PH . dVdq ; tau = Jv . '* ( 1e-3 * ( Xd - X ) - 1e-4 * Jv * log . dq ) + Vq ; end Code for plotting % Example 2b: plotting Model data % for loop over Model log files for ii = 1 : numel ( mdl . Log . t ) shp = shp . render ( mdl . Log . x ( ii , 1 : 6 )); % render shape if ii == 1 , % render setpoint Xd plotpoint ( Xd ); end axis ([ 0 100 - 5 , 5 , - 10 , 30 ]); view ( 30 , 30 ); drawnow ; end Example 4: Open-loop control of soft hand % CODE: Example 3 -- Open-loop controller % connect to controller board brd = Bdog ( 'pi' , '192.168.0.2' , 'pwd' , ... 'NVeab' , 3 ); % set board update frequency brd = brd . set ( 'Frequency' , 120 ); % phase offset per finger phi = @( k ) ( k - 1 ) * pi / 6 ; %% execute control loop for T=10s while brd . loop ( 10 ) T = ones ( 5 , 1 ) * brd . t ; Pd = zeros ( 1 , 6 ); Pd ( 1 : 5 ) = 80 * sign ( sin ( 4 * T - phi ( 1 : 5 ). ' )) * ... smoothstep ( t - 1 ); brd . setInput ( Pd ); end % disconnect system brd . disconnect (); How to cite? If you are planning on using Sorotoki in your (academic) work, please consider citing the toolkit @misc { Caasenbrood2020 , author = {Caasenbrood, Brandon} , title = {Sorotoki - A Soft Robotics Toolkit for MATLAB} , year = {2020} , publisher = {GitHub} , journal = {GitHub repository} , howpublished = {\\url{https://github.com/BJCaasenbrood/SorotokiCode}} , } Shepherd, R. F., Ilievski, F., Choi, W., Morin, S. A., Stokes, A. A., Mazzeo, A. D., ...Whitesides, G. M. (2011). Multigait soft robot. Proc. Natl. Acad. Sci. U.S.A., 22123978. Retrieved from https://pubmed.ncbi.nlm.nih.gov/22123978 doi: https://doi.org/10.1073/pnas.1116564108 \u21a9 Suzumori, K., Iikura, S., & Tanaka, H. (1991). Development of flexible microactuator and its applications to robotic mechanisms. Proceedings. 1991 IEEE International Conference on Robotics and Automation. IEEE. doi: https://doi.org/10.1109/ROBOT.1991.131850 \u21a9 Mosadegh, B., Polygerinos, P., Keplinger, C., Wennstedt, S., Shepherd, R. F., Gupta, U., ...Whitesides, G. M. (2014). Pneumatic Networks for Soft Robotics that Actuate Rapidly. Adv. Funct. Mater., 24(15), 2163\u20132170. doi: https://doi.org/10.1002/adfm.201303288 \u21a9 1981 - Robot Arm with Pneumatic Gripper - Nikolai Teleshev (Russian) - cyberneticzoo.com. (2012, April 08). Retrieved from http://cyberneticzoo.com/bionics/1981-robot-arm-with-pneumatic-gripper-nikolai-teleshev-russian \u21a9","title":"Sorotoki - a MATLAB toolkit for soft robotics"},{"location":"#sorotoki-a-matlab-toolkit-for-soft-robotics","text":"Sorotoki v3.0.01 stable (Code) Sorobots v1.0 (Soft robot STL) Github page is still under construction. Not all documentation is present at the this stage of development.","title":"Sorotoki - a MATLAB toolkit for soft robotics"},{"location":"#about-sorotoki","text":"Sorotoki is an open-source MATLAB toolkit for soft robotics that includes an array of tools for design, modeling, and control. Due to its scientific diversity, it can be challenging for new researchers to quickly familiarize themselves with multiple scientific areas. With the aim to lower this threshold, Sorotoki aims to incorporate multiple layers of soft robotics research into one compact toolkit. Examples include: continuum mechanics, dynamic systems and control theory, topology optimization, computer graphics, and much more to come! The combination provides a highly flexible programming environment and will hopefully aid the development of novel soft robotic research.","title":"About Sorotoki"},{"location":"#what-can-sorotoki-do","text":"Sorotoki started out small, but at its current state, it contains a vast collection of functionalities -- tailored towards many aspects of soft robotics. For example, suppose you are inspired by the multi-gait soft crawler developed by Shepard et al. 1 -- See video . Or you want to simulate the incredibly dexterous soft gripper developed by Suzumori et al. 2 -- See video . Can we model such systems easily? Well.... Short answer: no . As matter of fact, simplifying the (infinite-dimensional) dynamics of soft robots is no easy feat. It has been an active topic of research for the better part of the last two decades. Ironically, studying \"soft\" robotics is incredibly \"hard\" . Sorotoki, however, can simplify the process of design, modeling and control for soft robots. Our aim is to make research into soft robotics more accessable by dividing the problem into smaller, more manageable steps. Multi-physics solvers are included into Sorotoki and can accesses with minimal programming complexity. Simulation of multi-gait crawling soft robot undergoing an undulating motion. The model is inspired by the work of Shepard et al. (2011). Original soft robot can be found here: Youtube video Simulation of multi-finger soft gripper grasping a beaker and manipulating a M10 boltscrew. The model is inspired by the work of Suzumori et al. (1989). Original soft gripper can be found here: Youtube video Is it easy to code? Well, absolutely!","title":"What can Sorotoki do?"},{"location":"#list-of-functionalities","text":"To summarize, some of the functionalities included in the toolkit are listed below: Design: Implicit modeling using signed distance functions (SDFs), 2D-3D mesh generation, computational design using gradient-based optimization Modeling: Finite Element Models (FEM), high-efficiency reduced-order soft beam models (Lagrangian or port-Hamiltonian), easy programmable interconnections of a network of dynamical (soft robot) systems Control: Real-time (pneumatic) control platform using Raspberry Pi, vision-based sensing algorithms using Intel Realsense Depth camera Visualization: Fast and responsive 3D graphics rendering, mesh deformation modifiers (scaling, rotation, bending, twisting, mirroring), Forward Kinematic/Inverse Kinematic-rigging Accessibility: Minimal programming environment (i.e, focused on expressing complex problems with minimal lines of code). Open hardware: Four 3D-printable soft robots (e.g., soft hand, soft manipulator), and control interface).","title":"List of functionalities"},{"location":"#short-examples","text":"Example 1: PneuNet deformations A classic example in soft robotics is the PneuNet soft bending actuator. The PneuNet (pneumatic network) belongs to a class of soft actuators that, due to a geometrically induced stiffness differential, undergoes bending when pressurized. The geometry of the PneuNet is developed (and popularized) by Mosadegh et al. 3 , but historically it is much older 4 . To model the PneuNet actuator, consider the following numerical example. Assuming plane strain , we can simulate the nonlinear bending characteristics of the Pneunet actuator using the super-short code below (only 10 lines of code!): Code for simulation % generate mesh from image msh = Mesh ( 'Pneunet.png' , ... 'ElementSize' , 1 , ... 'BdBox' , [ 0 , 120 , 0 , 20 ]); % finite element solver (FEM) fem = Fem ( msh , 'Material' , NeoHookean ( 1.0 , 0.4 ), ... 'TimeStep' , 1e-2 ); % boundary conditions fem = fem . addGravity (); fem = fem . addPressure ( 'All' , 30 * kpa ); fem = fem . addConstraint ( 'Left' , [ 1 , 1 ]); % magic fem = fem . solve (); % take away message: simplicity > complexity Code for plotting Once a simulation is completed, there exist simple command to export the simulation as a .gif file. We can simple use the command below. This sets the frames-per-second (FPS), the axis for the replay video, and gif = true to make a gif file. fem . replay ( 'fps' , 60 , ... 'axis' ,[ - 33 , 120 - 86 21 ], ... 'gif' , true ) Example 2: Fitting hyper-elastic materials Example 3: Task-space controller for soft manipulator The next example shows the implementation of model-based controllers in Sorotoki. Consider a soft tentacle of length \\(L = 100\\) mm, radius \\(R = 5\\) mm, and a tapering of \\(75\\%\\) . We assume the tentacle is composed of DragonSkin10A silicone. \\[\\tau = J_v(q)^\\top\\left[k_p (X_d - X) - k_d \\dot{X}\\right] + \\nabla_q \\mathcal{V}\\] where \\(J_v(q) := \\lfloor J(q,L) \\rfloor_3\\) is the linear velocity part of the manipulator Jacobian matrix at the tip ( \\(\\sigma = L\\) ), \\(\\nabla_q \\mathcal{V}\\) is simply the gradient of the potential energy w.r.t to its states \\(q\\) , \\(X\\) and \\(X_d\\) the end-effector position and the desired position, respectively. Note that we can compute the end-effector velocity by \\(\\dot{X} = J_v(q) \\dot{q}\\) . Code for simulation % CODE: Example 2 -- Task-space controller % assign desired setpoint Xd = [ 30 ; 10 ; 10 ]; % build continuum shape POD = chebyspace ( 60 , 3 ); % POD basis shp = Shapes ( POD ,[ 0 , 3 , 3 , 0 , 0 , 0 ], ... % pure bending XY 'Length' , 100 , ... 'Material' , Dragonskin10 ); % geometry and boundary conditions shp = shp . setRadius ( 5 ); % R = 5 mm shp = shp . setRamp ( 0.75 ); % R is reduced by 75% at s=L shp = shp . addGravity (); % model composer mdl = Model ( shp , 'TimeStep' , 1 / 60 , ... 'Controller' , @( x ) tau ( x , Xd ) ); % magic ;) mdl = mdl . simulate (); % task-space controller (called by solver) function tau = tau ( mdl,Xd ) log = mdl . Systems { 1 }. Log ; X = log . FK . g ( 1 : 3 , 4 , end ); Jv = log . FK . J ( 4 : 6 ,:, end ); Vq = log . PH . dVdq ; tau = Jv . '* ( 1e-3 * ( Xd - X ) - 1e-4 * Jv * log . dq ) + Vq ; end Code for plotting % Example 2b: plotting Model data % for loop over Model log files for ii = 1 : numel ( mdl . Log . t ) shp = shp . render ( mdl . Log . x ( ii , 1 : 6 )); % render shape if ii == 1 , % render setpoint Xd plotpoint ( Xd ); end axis ([ 0 100 - 5 , 5 , - 10 , 30 ]); view ( 30 , 30 ); drawnow ; end Example 4: Open-loop control of soft hand % CODE: Example 3 -- Open-loop controller % connect to controller board brd = Bdog ( 'pi' , '192.168.0.2' , 'pwd' , ... 'NVeab' , 3 ); % set board update frequency brd = brd . set ( 'Frequency' , 120 ); % phase offset per finger phi = @( k ) ( k - 1 ) * pi / 6 ; %% execute control loop for T=10s while brd . loop ( 10 ) T = ones ( 5 , 1 ) * brd . t ; Pd = zeros ( 1 , 6 ); Pd ( 1 : 5 ) = 80 * sign ( sin ( 4 * T - phi ( 1 : 5 ). ' )) * ... smoothstep ( t - 1 ); brd . setInput ( Pd ); end % disconnect system brd . disconnect ();","title":"Short examples"},{"location":"#how-to-cite","text":"If you are planning on using Sorotoki in your (academic) work, please consider citing the toolkit @misc { Caasenbrood2020 , author = {Caasenbrood, Brandon} , title = {Sorotoki - A Soft Robotics Toolkit for MATLAB} , year = {2020} , publisher = {GitHub} , journal = {GitHub repository} , howpublished = {\\url{https://github.com/BJCaasenbrood/SorotokiCode}} , } Shepherd, R. F., Ilievski, F., Choi, W., Morin, S. A., Stokes, A. A., Mazzeo, A. D., ...Whitesides, G. M. (2011). Multigait soft robot. Proc. Natl. Acad. Sci. U.S.A., 22123978. Retrieved from https://pubmed.ncbi.nlm.nih.gov/22123978 doi: https://doi.org/10.1073/pnas.1116564108 \u21a9 Suzumori, K., Iikura, S., & Tanaka, H. (1991). Development of flexible microactuator and its applications to robotic mechanisms. Proceedings. 1991 IEEE International Conference on Robotics and Automation. IEEE. doi: https://doi.org/10.1109/ROBOT.1991.131850 \u21a9 Mosadegh, B., Polygerinos, P., Keplinger, C., Wennstedt, S., Shepherd, R. F., Gupta, U., ...Whitesides, G. M. (2014). Pneumatic Networks for Soft Robotics that Actuate Rapidly. Adv. Funct. Mater., 24(15), 2163\u20132170. doi: https://doi.org/10.1002/adfm.201303288 \u21a9 1981 - Robot Arm with Pneumatic Gripper - Nikolai Teleshev (Russian) - cyberneticzoo.com. (2012, April 08). Retrieved from http://cyberneticzoo.com/bionics/1981-robot-arm-with-pneumatic-gripper-nikolai-teleshev-russian \u21a9","title":"How to cite?"},{"location":"contact/","text":"Developer(s) Almost 4,5 years ago, Sorotoki began as a minuscule Matlab folder called librarySoftRobotics . As a starting PhD student, the trenches of the field of soft robotics ran deep and far. Very quickly, the folder grew and grew -- and it was slowly becoming an unorganized mess. The main problem stemmed (and still stems) from its multidisciplinary nature -- each Matlab script solved \"one\" and \"non-generalizable\" solution. There was no cross-compatibility between the code... As a solution, I began collecting my code into one compact toolkit called: Sorotoki -- short for So ft Ro botics To ol Ki t. Main developer Email Google Scholar Github Discord Brandon Caasenbrood works as a Ph.D. candidate in the Dynamics and Control group within the Mechanical Engineering department. He is currently involved in the Wearable Robotics perspective program, which explores soft robotics -- a subfield of robotics where rigid materials are substituted for softer alternatives. Naturally, these systems have major human-robot safety benefits relevant to wearable robotics. Besides, their intrinsic softness allows for higher-degree mobility that is difficult to achieve in their rigid counterparts. The main inspiration for soft robots stems from biology, with the aim of achieving similar performance and dexterity as biological creatures. Although the field has made significant steps have been towards bridging biology and robotics, its innate infinite dimensionality poses substantial challenges on design, modeling, and control. The diligence of achieving similar precision and speed to nowadays\u2019 rigid robots, and ultimately nature, stresses the paramount importance of novel engineering strategies tailored for soft robotics. His research tackles the problems within the design and control of these soft robots by exploring first principle methods. His interest lies in the computational design of continuum structure, nonlinear dynamics, and model-based control in the context of bio\u2011inspired soft robots. The emphasis here is on bridging the gaps between nature and robotics on a hardware and software level.","title":"Developer(s)"},{"location":"contact/#developers","text":"Almost 4,5 years ago, Sorotoki began as a minuscule Matlab folder called librarySoftRobotics . As a starting PhD student, the trenches of the field of soft robotics ran deep and far. Very quickly, the folder grew and grew -- and it was slowly becoming an unorganized mess. The main problem stemmed (and still stems) from its multidisciplinary nature -- each Matlab script solved \"one\" and \"non-generalizable\" solution. There was no cross-compatibility between the code... As a solution, I began collecting my code into one compact toolkit called: Sorotoki -- short for So ft Ro botics To ol Ki t. Main developer Email Google Scholar Github Discord Brandon Caasenbrood works as a Ph.D. candidate in the Dynamics and Control group within the Mechanical Engineering department. He is currently involved in the Wearable Robotics perspective program, which explores soft robotics -- a subfield of robotics where rigid materials are substituted for softer alternatives. Naturally, these systems have major human-robot safety benefits relevant to wearable robotics. Besides, their intrinsic softness allows for higher-degree mobility that is difficult to achieve in their rigid counterparts. The main inspiration for soft robots stems from biology, with the aim of achieving similar performance and dexterity as biological creatures. Although the field has made significant steps have been towards bridging biology and robotics, its innate infinite dimensionality poses substantial challenges on design, modeling, and control. The diligence of achieving similar precision and speed to nowadays\u2019 rigid robots, and ultimately nature, stresses the paramount importance of novel engineering strategies tailored for soft robotics. His research tackles the problems within the design and control of these soft robots by exploring first principle methods. His interest lies in the computational design of continuum structure, nonlinear dynamics, and model-based control in the context of bio\u2011inspired soft robots. The emphasis here is on bridging the gaps between nature and robotics on a hardware and software level.","title":"Developer(s)"},{"location":"install/","text":"Installation The toolkit is easy to install. The fastest and easiest way to acquire the toolkit is through git . We highly recommend using Git, since this allows you also to update the toolkit. Prerequisite toolboxes of MATLAB To use Sorotoki, make sure you have the following dependencies installed: Optimization Toolbox Partial Differential Equation Toolbox Image Processing Toolbox Matlab Coder Step-by-step installation Step 1: Downloading the Sorotoki installation folder You can directly clone the repository using the command: git clone --depth 1 https://github.com/BJCaasenbrood/SorotokiCode.git Alternatively, you can download the latest version of the toolkit below, and unpack the compressed folder at any desired working directory. We do recommend that the installation folder of the toolkit named: SorotokiCode is under the folder ...\\Documents\\Matlab\\ (at least for Windows and Linux OS's). Toolkit installation size (only code): ~20 MB Toolkit installation size (with STL data): ~120 MB \ud83d\uddff Direct-download Sorotoki v.2.19.stable (code) Sorotoki v.2.19.stable (code + STLs) Step 3: Run the installation Once all the prerequisites are (properly) installed, you first have to configure the toolkit with MATLAB's search paths. Setting up these paths is relatively straightforward. Simply run: sorotoki (); The file should be located under ...\\Documents\\MATLAB\\SorotokiCode\\. The toolkit will proceed the installation by building search paths in Matlab. The toolkit will request the installation of the prerequisite toolboxes if they are not installed. These include: Optimization Toolbox, Partial Differential Equation Toolbox, Image Processing Toolbox and Matlab Coder. Especially the latter ensures that embedded Sorotoki functions can be converted to c or c++ equivalent code in the form of mex files; that greatly enhances computational performance. Finally, a verification routine is performed that checks if the toolkit is installed correctly. Step 4: That's it folks And that's it, Sorotoki is now ready to use. The sorotoki installation command can also be used to run demo, check updates, see version number, and find the documentation file. You can do these by running the following commands: sorotoki demo % list demos sorotoki d % ... sorotoki version % version (and do i need to update?) sorotoki v % ... sorotoki doc % documentation link sorotoki i % ... Darn', problems during installation? Please let me know by: Post an issue at: https://github.com/BJCaasenbrood/SorotokiCode/issues","title":"Installation"},{"location":"install/#installation","text":"The toolkit is easy to install. The fastest and easiest way to acquire the toolkit is through git . We highly recommend using Git, since this allows you also to update the toolkit. Prerequisite toolboxes of MATLAB To use Sorotoki, make sure you have the following dependencies installed: Optimization Toolbox Partial Differential Equation Toolbox Image Processing Toolbox Matlab Coder","title":"Installation"},{"location":"install/#step-by-step-installation","text":"","title":"Step-by-step installation"},{"location":"install/#step-1-downloading-the-sorotoki-installation-folder","text":"You can directly clone the repository using the command: git clone --depth 1 https://github.com/BJCaasenbrood/SorotokiCode.git Alternatively, you can download the latest version of the toolkit below, and unpack the compressed folder at any desired working directory. We do recommend that the installation folder of the toolkit named: SorotokiCode is under the folder ...\\Documents\\Matlab\\ (at least for Windows and Linux OS's). Toolkit installation size (only code): ~20 MB Toolkit installation size (with STL data): ~120 MB \ud83d\uddff Direct-download Sorotoki v.2.19.stable (code) Sorotoki v.2.19.stable (code + STLs)","title":"Step 1: Downloading the Sorotoki installation folder"},{"location":"install/#step-3-run-the-installation","text":"Once all the prerequisites are (properly) installed, you first have to configure the toolkit with MATLAB's search paths. Setting up these paths is relatively straightforward. Simply run: sorotoki (); The file should be located under ...\\Documents\\MATLAB\\SorotokiCode\\. The toolkit will proceed the installation by building search paths in Matlab. The toolkit will request the installation of the prerequisite toolboxes if they are not installed. These include: Optimization Toolbox, Partial Differential Equation Toolbox, Image Processing Toolbox and Matlab Coder. Especially the latter ensures that embedded Sorotoki functions can be converted to c or c++ equivalent code in the form of mex files; that greatly enhances computational performance. Finally, a verification routine is performed that checks if the toolkit is installed correctly.","title":"Step 3: Run the installation"},{"location":"install/#step-4-thats-it-folks","text":"And that's it, Sorotoki is now ready to use. The sorotoki installation command can also be used to run demo, check updates, see version number, and find the documentation file. You can do these by running the following commands: sorotoki demo % list demos sorotoki d % ... sorotoki version % version (and do i need to update?) sorotoki v % ... sorotoki doc % documentation link sorotoki i % ...","title":"Step 4: That's it folks"},{"location":"install/#darn-problems-during-installation","text":"Please let me know by: Post an issue at: https://github.com/BJCaasenbrood/SorotokiCode/issues","title":"Darn', problems during installation?"},{"location":"release/","text":"Release Notes 2.07.22 - July 22 - 2022 Documentation update to the examples Modeling. Added minor description in auxilary functions in /src/ Fem.m Generated new mex files for the Local element computation. Now each matrix computation in during the fem simulation calls a .mex64 file. This significantly improves performance ~40% compare to .m files. During install, Sorotoki will ask to install the new mex files. Added (proper) friction effects to the contact simulations. A good example is fem_bouncingball.m which initally started spinning due to improper implementation of the friction forces during contact. The interaction friction can be modified under Material.Cfr (default = 1e-6 for most sample materials). Added example to show the friction effects is: ./scripts/fem/2D/dynamics/fem_crawler.m High interaction friction forces lead to instabilities, implement with caution. A fix will be issued later. Added initial conditions to the dynamic Fem simulations. Now Fem.Utmpcan be overwritten before calling fem.simulate. This can be extremely handy if we like to simulate from a quasi-static equilbrium, e.g., gravity deflection. One can first call fem.solve(), get the displacement through U0 = fem.Log.U(end,:) , then a new simulation: fem . reset (); fem . set ( 'Utmp' , U0 ); fem . simulate (); We can also ensure there is no ramping of the gravity force by setting the following fem.set('GravityRamp',false); Shapes.m Major update to the class. Now, Shapes.reconstruct() will produce better POD bases from the finite element simulations. As example: shp = Shapes ( fem , Modal , 'NNode' , 100 , 'L0' , 120 , 'FilterRadius' ,[ 15 , 15 ]); shp = shp . reference ([ 0 , 0 ],[ 119 , 0 ]); shp = shp . reconstruct (); This code will generate a basis from the data in Fem, and project its dynamics onto a curve spanned by the points: (0,0) -> (119,0). During the reconstruction, all system tensors are build accordingly. Shapes.show() is implemented and will show the strain basis. Model.m Fixed a minus error in the gravitional force compuation that lead to incorrect orientation of the gravity vector. 2.05.19 - May 19 - 2022 Fem.m : Addressed to solve Issue #7 : Fixed issue with Fem.Log. If a nonlinear residual increment takes less than 2 iterations, data was not properly stored. To solve this, any nonlinear time increment must take at least two steps, as to ensure a new displacement field is introduced to the stress-strain calculations. 2.05.17 - May 17 - 2022 Added MEX compiler for Model, Gmodel, and Fem classes. This significantly improves the computation times of the Sorotoki toolkit. When calling sorotoki.m , the installer asks to compile the mex files. Note we do not support the original Matlab functions anymore, simple because of computational speed. Hence, the Matlab Coder Toolkit is a prerequisite for Sorotoki. Updated verifySorotoki.m to include also Model. Shapes Updated the Fem -> Shapes converter that extracts the geometric modes from dynamic or quasi-static FEM data. This can be done using shp.Fem = Fem followed by shp.reconstruct , shp.rebuild . Then a dynamic model can be generated using mdl = Model(shp) . We call this new strain basis the Geometry-Informed Variable Strain basis as the geometry of the soft robot is preserved into the functional basis. Added Shapes.Material. Now hyper-elastic materials can be loaded into the stiffness and inertia tensor construction. The work is experimental since more research is required to properly include hyper-elastic materials into the Cosserat beam models. Model Added an auxiliary flow function to the Model class: dx = f(x,t) . This can be used for integrator actions, like PI controllers. or adaptive controllers where unknown parameters evolutions can be included. 2.01.28 - Jan 28 - 2022 Improved stability of Newmark solver. 2.24.01 - Jan 24 - 2022 Fixed broken installer. vernum.m file was missing on Repo. It has been replaced with soropatch.m which also includes the patch notes. @martijnschouten Missing DOI for citation, and long-term support/access. Signed Distance Functions : Added a new function Sdf.showcontour() . It will show the contour of 2D signed distance functions. Currently not implemented for 3D Sdfs. 2.13.01 - Jan 13 - 2022 Moved SOROTOKI from early alpha to alpha (prepping for official release). Shapes.m : Significant update to the class Shapes. Shapes now requests a Fem class , a Matlab function_handle of functionals, or a evaluated matrix of shape functions (); to construct the class. Then, it serves as an input for the class Model (e.g., dynamic modeling of soft robots), or as an Inverse Kinematic solver for beam models. Added a function Shapes.jointEstimate(Fem) . This will produce an optimal set of modal coefficient to reconstruct the beam model from FEM-driven data (accessed by Fem.Log). Current Shapes.jointEstimate() exploits the fact that the shapes are orthonormal w.r.t. their integral over the spatial domain [0,L]. If shapes do not satisfy this conditions, inaccurate estimates can occur. Added Y = gsog_poly(X) which ensure the columns of Y are mutually orthonormal derived from the matrix X. X must be full-rank. This function is simply the gramm-smith method for the innerproduct space int_C y_i y_j ds on the domain C := [0,L]. 1.12.06 - Dec 6 - 2021 Fem.m : Fixed some numerical issues with Fem.simulate() function. Stability is now further improved for larger timesteps. Fixed some numerical issues with Fem.Contact . A wider range of TimeSteps result now in stable solutions. Still the timestep size should be taken with care. Also fixed the issues of induced (unstable) oscillations due to fast impact. Contact is now based on the initial Modulus of the hyper-elastic material,i.e., Material.Emod() . Added time-base function_handle for the external pressures in dynamic finite-element simulations. They can added using: Fem.AddConstraint('Pressure',id, @(t) sin(t)) ; Dynamic simulations now record the potential and kinetic energies. Future implementation will have Load and Tendon-based dynamic forces The potential energy of the external load is still missing... 1.12.02 - Dec 2 - 2021 Finite Elements : Added Fem.simulate() function to the Nonlinear Finite Element. The function is a standard Newmark-Beta dynamic solver routine for NLFEM. Alternatively, fem.simulate() can be used as an alternative for fem.solve() by setting the Fem.Material.Zeta large (overdamped). Fixed the stability issue of Fem.Contact. Contact can now be added with Fem.AddConstraint('Contact',@(x) sdf(x), [x,y]) (x and y move the SDF). for best stability, use Fem.simulate() with a TimeStep < 1/75 . Open issues : Fem.simulate does not use dynamic external forces, rather the forces are scaled with a sigmoid function f_ext = f*sigmoid(t); This will be removed in the future with fext = @(t) f* .... - an explicit function of time that can be evaluated at time t. Possible implementations: Displace, Load, Pressure, Gravity. 1.10.06 - Oct 6 - 2021 Added patch.md file to keep track of any changes to SOROTOKI. Meshing : Fixed an issue where Mesh.showSDF was not producing plots. 1.10.01 - Oct 1 - 2021 Official beta release of SOROTOKI","title":"Release Notes"},{"location":"release/#release-notes","text":"","title":"Release Notes"},{"location":"release/#20722-july-22-2022","text":"Documentation update to the examples Modeling. Added minor description in auxilary functions in /src/ Fem.m Generated new mex files for the Local element computation. Now each matrix computation in during the fem simulation calls a .mex64 file. This significantly improves performance ~40% compare to .m files. During install, Sorotoki will ask to install the new mex files. Added (proper) friction effects to the contact simulations. A good example is fem_bouncingball.m which initally started spinning due to improper implementation of the friction forces during contact. The interaction friction can be modified under Material.Cfr (default = 1e-6 for most sample materials). Added example to show the friction effects is: ./scripts/fem/2D/dynamics/fem_crawler.m High interaction friction forces lead to instabilities, implement with caution. A fix will be issued later. Added initial conditions to the dynamic Fem simulations. Now Fem.Utmpcan be overwritten before calling fem.simulate. This can be extremely handy if we like to simulate from a quasi-static equilbrium, e.g., gravity deflection. One can first call fem.solve(), get the displacement through U0 = fem.Log.U(end,:) , then a new simulation: fem . reset (); fem . set ( 'Utmp' , U0 ); fem . simulate (); We can also ensure there is no ramping of the gravity force by setting the following fem.set('GravityRamp',false); Shapes.m Major update to the class. Now, Shapes.reconstruct() will produce better POD bases from the finite element simulations. As example: shp = Shapes ( fem , Modal , 'NNode' , 100 , 'L0' , 120 , 'FilterRadius' ,[ 15 , 15 ]); shp = shp . reference ([ 0 , 0 ],[ 119 , 0 ]); shp = shp . reconstruct (); This code will generate a basis from the data in Fem, and project its dynamics onto a curve spanned by the points: (0,0) -> (119,0). During the reconstruction, all system tensors are build accordingly. Shapes.show() is implemented and will show the strain basis. Model.m Fixed a minus error in the gravitional force compuation that lead to incorrect orientation of the gravity vector.","title":"2.07.22 - July 22 - 2022"},{"location":"release/#20519-may-19-2022","text":"Fem.m : Addressed to solve Issue #7 : Fixed issue with Fem.Log. If a nonlinear residual increment takes less than 2 iterations, data was not properly stored. To solve this, any nonlinear time increment must take at least two steps, as to ensure a new displacement field is introduced to the stress-strain calculations.","title":"2.05.19 - May 19 - 2022"},{"location":"release/#20517-may-17-2022","text":"Added MEX compiler for Model, Gmodel, and Fem classes. This significantly improves the computation times of the Sorotoki toolkit. When calling sorotoki.m , the installer asks to compile the mex files. Note we do not support the original Matlab functions anymore, simple because of computational speed. Hence, the Matlab Coder Toolkit is a prerequisite for Sorotoki. Updated verifySorotoki.m to include also Model. Shapes Updated the Fem -> Shapes converter that extracts the geometric modes from dynamic or quasi-static FEM data. This can be done using shp.Fem = Fem followed by shp.reconstruct , shp.rebuild . Then a dynamic model can be generated using mdl = Model(shp) . We call this new strain basis the Geometry-Informed Variable Strain basis as the geometry of the soft robot is preserved into the functional basis. Added Shapes.Material. Now hyper-elastic materials can be loaded into the stiffness and inertia tensor construction. The work is experimental since more research is required to properly include hyper-elastic materials into the Cosserat beam models. Model Added an auxiliary flow function to the Model class: dx = f(x,t) . This can be used for integrator actions, like PI controllers. or adaptive controllers where unknown parameters evolutions can be included.","title":"2.05.17 - May 17 - 2022"},{"location":"release/#20128-jan-28-2022","text":"Improved stability of Newmark solver.","title":"2.01.28 - Jan 28 - 2022"},{"location":"release/#22401-jan-24-2022","text":"Fixed broken installer. vernum.m file was missing on Repo. It has been replaced with soropatch.m which also includes the patch notes. @martijnschouten Missing DOI for citation, and long-term support/access. Signed Distance Functions : Added a new function Sdf.showcontour() . It will show the contour of 2D signed distance functions. Currently not implemented for 3D Sdfs.","title":"2.24.01 - Jan 24 - 2022"},{"location":"release/#21301-jan-13-2022","text":"Moved SOROTOKI from early alpha to alpha (prepping for official release). Shapes.m : Significant update to the class Shapes. Shapes now requests a Fem class , a Matlab function_handle of functionals, or a evaluated matrix of shape functions (); to construct the class. Then, it serves as an input for the class Model (e.g., dynamic modeling of soft robots), or as an Inverse Kinematic solver for beam models. Added a function Shapes.jointEstimate(Fem) . This will produce an optimal set of modal coefficient to reconstruct the beam model from FEM-driven data (accessed by Fem.Log). Current Shapes.jointEstimate() exploits the fact that the shapes are orthonormal w.r.t. their integral over the spatial domain [0,L]. If shapes do not satisfy this conditions, inaccurate estimates can occur. Added Y = gsog_poly(X) which ensure the columns of Y are mutually orthonormal derived from the matrix X. X must be full-rank. This function is simply the gramm-smith method for the innerproduct space int_C y_i y_j ds on the domain C := [0,L].","title":"2.13.01 - Jan 13 - 2022"},{"location":"release/#11206-dec-6-2021","text":"Fem.m : Fixed some numerical issues with Fem.simulate() function. Stability is now further improved for larger timesteps. Fixed some numerical issues with Fem.Contact . A wider range of TimeSteps result now in stable solutions. Still the timestep size should be taken with care. Also fixed the issues of induced (unstable) oscillations due to fast impact. Contact is now based on the initial Modulus of the hyper-elastic material,i.e., Material.Emod() . Added time-base function_handle for the external pressures in dynamic finite-element simulations. They can added using: Fem.AddConstraint('Pressure',id, @(t) sin(t)) ; Dynamic simulations now record the potential and kinetic energies. Future implementation will have Load and Tendon-based dynamic forces The potential energy of the external load is still missing...","title":"1.12.06 - Dec 6 - 2021"},{"location":"release/#11202-dec-2-2021","text":"Finite Elements : Added Fem.simulate() function to the Nonlinear Finite Element. The function is a standard Newmark-Beta dynamic solver routine for NLFEM. Alternatively, fem.simulate() can be used as an alternative for fem.solve() by setting the Fem.Material.Zeta large (overdamped). Fixed the stability issue of Fem.Contact. Contact can now be added with Fem.AddConstraint('Contact',@(x) sdf(x), [x,y]) (x and y move the SDF). for best stability, use Fem.simulate() with a TimeStep < 1/75 . Open issues : Fem.simulate does not use dynamic external forces, rather the forces are scaled with a sigmoid function f_ext = f*sigmoid(t); This will be removed in the future with fext = @(t) f* .... - an explicit function of time that can be evaluated at time t. Possible implementations: Displace, Load, Pressure, Gravity.","title":"1.12.02 - Dec 2 - 2021"},{"location":"release/#11006-oct-6-2021","text":"Added patch.md file to keep track of any changes to SOROTOKI. Meshing : Fixed an issue where Mesh.showSDF was not producing plots.","title":"1.10.06 - Oct 6 - 2021"},{"location":"release/#11001-oct-1-2021","text":"Official beta release of SOROTOKI","title":"1.10.01 - Oct 1 - 2021"},{"location":"softmanipulator/","text":"Soft manipulator var iframe = document.getElementById( 'api-frame' ); var uid = '3fd62289149f4145856b9c664c033917'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } );","title":"Soft manipulator"},{"location":"softmanipulator/#soft-manipulator","text":"var iframe = document.getElementById( 'api-frame' ); var uid = '3fd62289149f4145856b9c664c033917'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } );","title":"Soft manipulator"},{"location":"control/controlboard/","text":"VEAB hat (RPi) Image caption Schematics of the VEAB Raspberry Pi controller hat Printer-Circuit Board (PCB) Schematics (v2.11) Schematics of the VEAB Raspberry Pi controller hat Bill of material (BOM)","title":"VEAB hat (RPi)"},{"location":"control/controlboard/#veab-hat-rpi","text":"Image caption Schematics of the VEAB Raspberry Pi controller hat","title":"VEAB hat (RPi)"},{"location":"control/controlboard/#printer-circuit-board-pcb-schematics-v211","text":"Schematics of the VEAB Raspberry Pi controller hat","title":"Printer-Circuit Board (PCB) Schematics (v2.11)"},{"location":"control/controlboard/#bill-of-material-bom","text":"","title":"Bill of material (BOM)"},{"location":"fem/fem/","text":"Finite Elements","title":"Finite Elements"},{"location":"fem/fem/#finite-elements","text":"","title":"Finite Elements"},{"location":"fem/mesh/","text":"Mesh generation","title":"Mesh generation"},{"location":"fem/mesh/#mesh-generation","text":"","title":"Mesh generation"},{"location":"fem/sdf/","text":"Implicit CAD","title":"Implicit CAD"},{"location":"fem/sdf/#implicit-cad","text":"","title":"Implicit CAD"},{"location":"plotting/colormaps/","text":"Colormaps Overview fig ( 102 ,[ 10.75 , 10.75 ]); colormaplist = { 'blackwhite' , 'bluesea' , 'heatmap' , 'inferno' , 'metro' , ... 'noir' , 'turbo' , 'viridis' , 'bounce' , 'barney' , 'evolution' , ... 'rainbow' , 'polarmap' , 'redgreen' , 'soapbubble' }; N = numel ( colormaplist ); Nx = ceil ( sqrt ( N )); Ny = ceil ( sqrt ( N )); for ii = 1 : N ax = subplot ( Nx , Ny , ii ) ; colorwheel (); map = str2func ([ '@(x) ' , colormaplist { ii }]); colormap ( ax , map ([])); axis off tight ; end List of colormaps Improved colormaps of Sorotoki Colormap manipulation","title":"Colormaps"},{"location":"plotting/colormaps/#colormaps","text":"","title":"Colormaps"},{"location":"plotting/colormaps/#overview","text":"fig ( 102 ,[ 10.75 , 10.75 ]); colormaplist = { 'blackwhite' , 'bluesea' , 'heatmap' , 'inferno' , 'metro' , ... 'noir' , 'turbo' , 'viridis' , 'bounce' , 'barney' , 'evolution' , ... 'rainbow' , 'polarmap' , 'redgreen' , 'soapbubble' }; N = numel ( colormaplist ); Nx = ceil ( sqrt ( N )); Ny = ceil ( sqrt ( N )); for ii = 1 : N ax = subplot ( Nx , Ny , ii ) ; colorwheel (); map = str2func ([ '@(x) ' , colormaplist { ii }]); colormap ( ax , map ([])); axis off tight ; end List of colormaps Improved colormaps of Sorotoki","title":"Overview"},{"location":"plotting/colormaps/#colormap-manipulation","text":"","title":"Colormap manipulation"},{"location":"plotting/colors/","text":"Colors The standard color schemes are not optimized well (in my opinion). Especially when compared to the MatplotLib in Python. Therefore, Sorotoki comes equipped with a new color scheme. Improved color scheme for plotting lines Using Sorotoki color scheme(s) fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y ); end % magick color change sorocolor ; Improved color scheme for plotting using Sorotoki Alternative option An alternative option is to call the colors directly. We can use this using col(i) where i is the color index. The indexation is identical to the legend above. fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y , 'Color' , col ( ii )); end","title":"Colors"},{"location":"plotting/colors/#colors","text":"The standard color schemes are not optimized well (in my opinion). Especially when compared to the MatplotLib in Python. Therefore, Sorotoki comes equipped with a new color scheme.","title":"Colors"},{"location":"plotting/colors/#improved-color-scheme-for-plotting-lines","text":"Using Sorotoki color scheme(s) fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y ); end % magick color change sorocolor ; Improved color scheme for plotting using Sorotoki Alternative option An alternative option is to call the colors directly. We can use this using col(i) where i is the color index. The indexation is identical to the legend above. fig ( 101 ,[ 10 , 9 ]); for ii = 1 : 10 X = linspace ( 0 , pi * 3 , 1e5 ); Y = cos ( X + 1 * ii * pi / N ); plot ( X , Y , 'Color' , col ( ii )); end","title":"Improved color scheme for plotting lines"},{"location":"plotting/figure/","text":"Figures Making figures in Matlab is hassle some. By default, the background is gray instead of white. The line thickness is 0.5pt instead of a prettier 1.5pt . Also the bounding box of the graphs are not 1.0pt but instead 0.5pt . And the labels are by default not using the .latex interpreter. To make matters worse, we cannot scale figure size by default -- rather a set of commands are required to adjust figure size. To solve this, we introduce the fig() command. Making a fig figure % make figure of size (2^9) x (2^9) = 512 x 512 px fig ( 101 ,[ 9 , 9 ]); ezplot (@( x ) sin ( x ^ 2 )); xlabel ( '$x$' ); ylabel ( '$\\sin(x^2)$' ); Sorotoki figure Figure of size 512x512 pixels produced using fig() How about standard Matlab? Standard matlab figure result","title":"Figures"},{"location":"plotting/figure/#figures","text":"Making figures in Matlab is hassle some. By default, the background is gray instead of white. The line thickness is 0.5pt instead of a prettier 1.5pt . Also the bounding box of the graphs are not 1.0pt but instead 0.5pt . And the labels are by default not using the .latex interpreter. To make matters worse, we cannot scale figure size by default -- rather a set of commands are required to adjust figure size. To solve this, we introduce the fig() command. Making a fig figure % make figure of size (2^9) x (2^9) = 512 x 512 px fig ( 101 ,[ 9 , 9 ]); ezplot (@( x ) sin ( x ^ 2 )); xlabel ( '$x$' ); ylabel ( '$\\sin(x^2)$' ); Sorotoki figure Figure of size 512x512 pixels produced using fig() How about standard Matlab? Standard matlab figure result","title":"Figures"},{"location":"plotting/rendering/","text":"Rendering","title":"Rendering"},{"location":"plotting/rendering/#rendering","text":"","title":"Rendering"},{"location":"sorobots/softmanipulator/","text":"Soft manipulator var iframe = document.getElementById( 'api-frame' ); var uid = '3fd62289149f4145856b9c664c033917'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } );","title":"Soft manipulator"},{"location":"sorobots/softmanipulator/#soft-manipulator","text":"var iframe = document.getElementById( 'api-frame' ); var uid = '3fd62289149f4145856b9c664c033917'; // By default, the latest version of the viewer API will be used. var client = new Sketchfab( iframe ); // Alternatively, you can request a specific version. // var client = new Sketchfab( '1.12.1', iframe ); client.init( uid, { success: function onSuccess( api ){ api.start(); api.addEventListener( 'viewerready', function() { // API is ready to use // Insert your code here console.log( 'Viewer is ready' ); } ); }, error: function onError() { console.log( 'Viewer error' ); } } );","title":"Soft manipulator"}]}